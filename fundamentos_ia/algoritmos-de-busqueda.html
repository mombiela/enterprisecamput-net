<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search Algorithms</title>

    <link rel="alternate" href="https://campusempresa.com/fundamentos_ia/algoritmos-de-busqueda" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/fundamentos_ia/algoritmos-de-busqueda" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/fundamentos_ia/algoritmos-de-busqueda" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png" style="visibility:hiddenxx;"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Building today's and tomorrow's society</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
													<b id="lit_lang_es" class="px-2">EN</b>
				|
				<a href="https://campusempresa.com/fundamentos_ia/algoritmos-de-busqueda" class="px-2">ES</a></b>
				|
				<a href="https://campusempresa.cat/fundamentos_ia/algoritmos-de-busqueda" class="px-2">CA</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/objective">The Project</a>
				<a href="/about">About Us</a>
				<a href="/contribute">Contribute</a>
				<a href="/donate">Donations</a>
				<a href="/licence">License</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='content'></div><h1>Introduction</h1>
<div class='content'><p>Search algorithms are fundamental in the field of Artificial Intelligence (AI). These algorithms allow finding solutions to specific problems by exploring possible states or solutions. In this topic, we will explore key concepts, types of search algorithms, and practical examples to understand how they work.</p>
</div><h1>Key Concepts</h1>
<div class='content'><ul>
<li><strong>State Space</strong>: Set of all possible states that can be reached from the initial state.</li>
<li><strong>Node</strong>: Representation of a state in the state space.</li>
<li><strong>Path</strong>: Sequence of nodes that leads from the initial state to the goal state.</li>
<li><strong>Path Cost</strong>: Sum of the costs associated with the steps in the path.</li>
<li><strong>Evaluation Function</strong>: Function that assigns a value to each node, used to decide the next node to explore.</li>
</ul>
</div><h1>Types of Search Algorithms</h1>
<div class='content'></div><h2>Uninformed Search</h2>
<div class='content'><ol>
<li>
<p><strong>Breadth-First Search (BFS)</strong></p>
<ul>
<li>Explores all nodes at one depth level before moving to the next level.</li>
<li>Uses a queue (FIFO) to store nodes to be explored.</li>
<li><strong>Advantages</strong>: Guarantees finding the shortest solution if all step costs are equal.</li>
<li><strong>Disadvantages</strong>: Can be inefficient in terms of memory and time.</li>
</ul>
<pre><code class="language-python">from collections import deque

def bfs(graph, start, goal):
    queue = deque([start])
    visited = set()
    while queue:
        node = queue.popleft()
        if node == goal:
            return True
        if node not in visited:
            visited.add(node)
            queue.extend(graph[node] - visited)
    return False

graph = {
    'A': {'B', 'C'},
    'B': {'A', 'D', 'E'},
    'C': {'A', 'F'},
    'D': {'B'},
    'E': {'B', 'F'},
    'F': {'C', 'E'}
}

print(bfs(graph, 'A', 'F'))  # Output: True
</code></pre>
</li>
<li>
<p><strong>Depth-First Search (DFS)</strong></p>
<ul>
<li>Explores as deep as possible along each branch before backtracking.</li>
<li>Uses a stack (LIFO) to store nodes to be explored.</li>
<li><strong>Advantages</strong>: Requires less memory than BFS.</li>
<li><strong>Disadvantages</strong>: Does not guarantee finding the shortest solution and can get stuck in cycles.</li>
</ul>
<pre><code class="language-python">def dfs(graph, start, goal, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    if start == goal:
        return True
    for next_node in graph[start] - visited:
        if dfs(graph, next_node, goal, visited):
            return True
    return False

print(dfs(graph, 'A', 'F'))  # Output: True
</code></pre>
</li>
</ol>
</div><h2>Informed Search</h2>
<div class='content'><ol>
<li>
<p><em><em>A</em> Search (A-Star)</em>*</p>
<ul>
<li>Uses an evaluation function <code>f(n) = g(n) + h(n)</code>, where <code>g(n)</code> is the path cost from the start to node <code>n</code>, and <code>h(n)</code> is a heuristic that estimates the cost from <code>n</code> to the goal.</li>
<li><strong>Advantages</strong>: It is optimal and complete if the heuristic is admissible (never overestimates the real cost).</li>
<li><strong>Disadvantages</strong>: Can be costly in terms of memory and time.</li>
</ul>
<pre><code class="language-python">import heapq

def a_star(graph, start, goal, h):
    open_set = []
    heapq.heappush(open_set, (0, start))
    came_from = {}
    g_score = {start: 0}
    f_score = {start: h(start)}

    while open_set:
        _, current = heapq.heappop(open_set)
        if current == goal:
            return reconstruct_path(came_from, current)
        for neighbor, cost in graph[current].items():
            tentative_g_score = g_score[current] + cost
            if tentative_g_score &lt; g_score.get(neighbor, float('inf')):
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + h(neighbor)
                heapq.heappush(open_set, (f_score[neighbor], neighbor))
    return None

def reconstruct_path(came_from, current):
    total_path = [current]
    while current in came_from:
        current = came_from[current]
        total_path.append(current)
    return total_path[::-1]

graph = {
    'A': {'B': 1, 'C': 3},
    'B': {'A': 1, 'D': 1, 'E': 5},
    'C': {'A': 3, 'F': 2},
    'D': {'B': 1},
    'E': {'B': 5, 'F': 2},
    'F': {'C': 2, 'E': 2}
}

h = lambda x: {'A': 6, 'B': 5, 'C': 4, 'D': 3, 'E': 2, 'F': 1}[x]

print(a_star(graph, 'A', 'F', h))  # Output: ['A', 'C', 'F']
</code></pre>
</li>
</ol>
</div><h1>Comparison of Algorithms</h1>
<div class='content'><p>| Algorithm | Complete | Optimal | Time Complexity | Space Complexity |
|-----------|----------|---------|-----------------|------------------|
| BFS       | Yes      | Yes     | O(b^d)          | O(b^d)           |
| DFS       | No       | No      | O(b^m)          | O(bm)            |
| A*        | Yes      | Yes     | O(b^d)          | O(b^d)           |</p>
<ul>
<li><strong>Complete</strong>: Finds a solution if one exists.</li>
<li><strong>Optimal</strong>: Finds the shortest solution.</li>
<li><strong>Time Complexity</strong>: Time required to find the solution.</li>
<li><strong>Space Complexity</strong>: Memory required to store the nodes.</li>
</ul>
</div><h1>Conclusion</h1>
<div class='content'><p>Search algorithms are essential tools in Artificial Intelligence to solve problems efficiently. The choice of the appropriate algorithm depends on the characteristics of the problem, such as the size of the state space and the need to find the shortest solution. Understanding these algorithms and their practical implementation is crucial for developing effective AI solutions.</p>
</div></div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Advertising</h1>
			<p>This space is reserved for advertising.</p>
			<p>If you want to be a sponsor, contact us to include links in this area: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>Thank you for collaborating!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. All rights reserved</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Accept</a>
    <a href="/cookies">More Information</a>
</div>	

	</div>    
</body>
</html>
