<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Programming in C#</title>

    <link rel="alternate" href="https://campusempresa.com/mod/csharp/dynamic-programming" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/csharp/dynamic-programming" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/csharp/dynamic-programming" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo-header_enterprise.png"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Building today's and tomorrow's society</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
													<b id="lit_lang_es" class="px-2">EN</b>
				|
				<a href="https://campusempresa.com/mod/csharp/dynamic-programming" class="px-2">ES</a></b>
				|
				<a href="https://campusempresa.cat/mod/csharp/dynamic-programming" class="px-2">CA</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/objective">The Project</a>
				<a href="/about">About Us</a>
				<a href="/contribute">Contribute</a>
				<a href="/donate">Donations</a>
				<a href="/licence">License</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='row navigation'>
	<div class='col-4'>
					<a href='reflection'>&#x25C4;Reflection</a>
			</div>
	<div class='col-4 text-center'>
		<a href="./" class="title">Dynamic Programming in C#</a>
	</div>
	<div class='col-4 text-end'>
					<a href='memory-management'>Memory Management and Garbage Collection &#x25BA;</a>
			</div>
</div>
<div class='content'><p>Dynamic Programming (DP) is a powerful technique used in computer science to solve problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant computations. This topic will guide you through the basics to advanced concepts of Dynamic Programming in C#.</p>
</div><h1>Introduction to Dynamic Programming</h1>
<div class='content'><ul>
<li><strong>Definition</strong>: Dynamic Programming is a method for solving complex problems by breaking them down into simpler subproblems. It is applicable when the problem can be divided into overlapping subproblems which can be solved independently.</li>
<li><strong>Key Concepts</strong>:
<ul>
<li><strong>Overlapping Subproblems</strong>: Problems that can be broken down into subproblems which are reused several times.</li>
<li><strong>Optimal Substructure</strong>: The optimal solution of the problem can be constructed efficiently from optimal solutions of its subproblems.</li>
<li><strong>Memoization</strong>: Storing the results of expensive function calls and reusing them when the same inputs occur again.</li>
<li><strong>Tabulation</strong>: Building a table in a bottom-up manner to store the results of subproblems.</li>
</ul>
</li>
</ul>
</div><h1>Basic Example: Fibonacci Sequence</h1>
<div class='content'><p>The Fibonacci sequence is a classic example to illustrate Dynamic Programming.</p>
</div><h2>Recursive Approach (Inefficient)</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHVibGljIGludCBGaWJvbmFjY2koaW50IG4pCnsKICAgIGlmIChuIDw9IDEpCiAgICAgICAgcmV0dXJuIG47CiAgICByZXR1cm4gRmlib25hY2NpKG4gLSAxKSArIEZpYm9uYWNjaShuIC0gMik7Cn0="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>public int Fibonacci(int n)
{
    if (n &lt;= 1)
        return n;
    return Fibonacci(n - 1) + Fibonacci(n - 2);
}</pre></div><div class='content'><ul>
<li><strong>Explanation</strong>: This approach is simple but inefficient due to the repeated calculations of the same subproblems.</li>
</ul>
</div><h2>Memoization Approach</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHVibGljIGludCBGaWJvbmFjY2lNZW1vKGludCBuLCBEaWN0aW9uYXJ5PGludCwgaW50PiBtZW1vKQp7CiAgICBpZiAobWVtby5Db250YWluc0tleShuKSkKICAgICAgICByZXR1cm4gbWVtb1tuXTsKICAgIGlmIChuIDw9IDEpCiAgICAgICAgcmV0dXJuIG47CiAgICBtZW1vW25dID0gRmlib25hY2NpTWVtbyhuIC0gMSwgbWVtbykgKyBGaWJvbmFjY2lNZW1vKG4gLSAyLCBtZW1vKTsKICAgIHJldHVybiBtZW1vW25dOwp9CgovLyBVc2FnZQp2YXIgbWVtbyA9IG5ldyBEaWN0aW9uYXJ5PGludCwgaW50PigpOwppbnQgcmVzdWx0ID0gRmlib25hY2NpTWVtbygxMCwgbWVtbyk7CkNvbnNvbGUuV3JpdGVMaW5lKHJlc3VsdCk7IC8vIE91dHB1dDogNTU="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>public int FibonacciMemo(int n, Dictionary&lt;int, int&gt; memo)
{
    if (memo.ContainsKey(n))
        return memo[n];
    if (n &lt;= 1)
        return n;
    memo[n] = FibonacciMemo(n - 1, memo) + FibonacciMemo(n - 2, memo);
    return memo[n];
}

// Usage
var memo = new Dictionary&lt;int, int&gt;();
int result = FibonacciMemo(10, memo);
Console.WriteLine(result); // Output: 55</pre></div><div class='content'><ul>
<li><strong>Explanation</strong>: This approach stores the results of subproblems in a dictionary to avoid redundant calculations.</li>
</ul>
</div><h2>Tabulation Approach</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHVibGljIGludCBGaWJvbmFjY2lUYWIoaW50IG4pCnsKICAgIGlmIChuIDw9IDEpCiAgICAgICAgcmV0dXJuIG47CiAgICBpbnRbXSBmaWIgPSBuZXcgaW50W24gKyAxXTsKICAgIGZpYlswXSA9IDA7CiAgICBmaWJbMV0gPSAxOwogICAgZm9yIChpbnQgaSA9IDI7IGkgPD0gbjsgaSsrKQogICAgewogICAgICAgIGZpYltpXSA9IGZpYltpIC0gMV0gKyBmaWJbaSAtIDJdOwogICAgfQogICAgcmV0dXJuIGZpYltuXTsKfQoKLy8gVXNhZ2UKaW50IHJlc3VsdCA9IEZpYm9uYWNjaVRhYigxMCk7CkNvbnNvbGUuV3JpdGVMaW5lKHJlc3VsdCk7IC8vIE91dHB1dDogNTU="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>public int FibonacciTab(int n)
{
    if (n &lt;= 1)
        return n;
    int[] fib = new int[n + 1];
    fib[0] = 0;
    fib[1] = 1;
    for (int i = 2; i &lt;= n; i++)
    {
        fib[i] = fib[i - 1] + fib[i - 2];
    }
    return fib[n];
}

// Usage
int result = FibonacciTab(10);
Console.WriteLine(result); // Output: 55</pre></div><div class='content'><ul>
<li><strong>Explanation</strong>: This approach builds the solution in a bottom-up manner using an array to store the results of subproblems.</li>
</ul>
</div><h1>Intermediate Example: Longest Common Subsequence (LCS)</h1>
<div class='content'><p>The Longest Common Subsequence problem is another classic example of Dynamic Programming.</p>
</div><h2>Recursive Approach (Inefficient)</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHVibGljIGludCBMQ1Moc3RyaW5nIHMxLCBzdHJpbmcgczIsIGludCBtLCBpbnQgbikKewogICAgaWYgKG0gPT0gMCB8fCBuID09IDApCiAgICAgICAgcmV0dXJuIDA7CiAgICBpZiAoczFbbSAtIDFdID09IHMyW24gLSAxXSkKICAgICAgICByZXR1cm4gMSArIExDUyhzMSwgczIsIG0gLSAxLCBuIC0gMSk7CiAgICBlbHNlCiAgICAgICAgcmV0dXJuIE1hdGguTWF4KExDUyhzMSwgczIsIG0gLSAxLCBuKSwgTENTKHMxLCBzMiwgbSwgbiAtIDEpKTsKfQ=="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>public int LCS(string s1, string s2, int m, int n)
{
    if (m == 0 || n == 0)
        return 0;
    if (s1[m - 1] == s2[n - 1])
        return 1 + LCS(s1, s2, m - 1, n - 1);
    else
        return Math.Max(LCS(s1, s2, m - 1, n), LCS(s1, s2, m, n - 1));
}</pre></div><div class='content'><ul>
<li><strong>Explanation</strong>: This approach is simple but inefficient due to the exponential time complexity.</li>
</ul>
</div><h2>Dynamic Programming Approach</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHVibGljIGludCBMQ1Moc3RyaW5nIHMxLCBzdHJpbmcgczIpCnsKICAgIGludCBtID0gczEuTGVuZ3RoOwogICAgaW50IG4gPSBzMi5MZW5ndGg7CiAgICBpbnRbLF0gZHAgPSBuZXcgaW50W20gKyAxLCBuICsgMV07CgogICAgZm9yIChpbnQgaSA9IDA7IGkgPD0gbTsgaSsrKQogICAgewogICAgICAgIGZvciAoaW50IGogPSAwOyBqIDw9IG47IGorKykKICAgICAgICB7CiAgICAgICAgICAgIGlmIChpID09IDAgfHwgaiA9PSAwKQogICAgICAgICAgICAgICAgZHBbaSwgal0gPSAwOwogICAgICAgICAgICBlbHNlIGlmIChzMVtpIC0gMV0gPT0gczJbaiAtIDFdKQogICAgICAgICAgICAgICAgZHBbaSwgal0gPSBkcFtpIC0gMSwgaiAtIDFdICsgMTsKICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgZHBbaSwgal0gPSBNYXRoLk1heChkcFtpIC0gMSwgal0sIGRwW2ksIGogLSAxXSk7CiAgICAgICAgfQogICAgfQogICAgcmV0dXJuIGRwW20sIG5dOwp9CgovLyBVc2FnZQppbnQgcmVzdWx0ID0gTENTKCJBR0dUQUIiLCAiR1hUWEFZQiIpOwpDb25zb2xlLldyaXRlTGluZShyZXN1bHQpOyAvLyBPdXRwdXQ6IDQ="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>public int LCS(string s1, string s2)
{
    int m = s1.Length;
    int n = s2.Length;
    int[,] dp = new int[m + 1, n + 1];

    for (int i = 0; i &lt;= m; i++)
    {
        for (int j = 0; j &lt;= n; j++)
        {
            if (i == 0 || j == 0)
                dp[i, j] = 0;
            else if (s1[i - 1] == s2[j - 1])
                dp[i, j] = dp[i - 1, j - 1] + 1;
            else
                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
        }
    }
    return dp[m, n];
}

// Usage
int result = LCS(&quot;AGGTAB&quot;, &quot;GXTXAYB&quot;);
Console.WriteLine(result); // Output: 4</pre></div><div class='content'><ul>
<li><strong>Explanation</strong>: This approach uses a 2D array to store the lengths of LCS of substrings, resulting in a polynomial time complexity.</li>
</ul>
</div><h1>Advanced Example: Knapsack Problem</h1>
<div class='content'><p>The Knapsack problem is a well-known optimization problem.</p>
</div><h2>Recursive Approach (Inefficient)</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHVibGljIGludCBLbmFwc2FjayhpbnRbXSB3ZWlnaHRzLCBpbnRbXSB2YWx1ZXMsIGludCBXLCBpbnQgbikKewogICAgaWYgKG4gPT0gMCB8fCBXID09IDApCiAgICAgICAgcmV0dXJuIDA7CiAgICBpZiAod2VpZ2h0c1tuIC0gMV0gPiBXKQogICAgICAgIHJldHVybiBLbmFwc2Fjayh3ZWlnaHRzLCB2YWx1ZXMsIFcsIG4gLSAxKTsKICAgIGVsc2UKICAgICAgICByZXR1cm4gTWF0aC5NYXgodmFsdWVzW24gLSAxXSArIEtuYXBzYWNrKHdlaWdodHMsIHZhbHVlcywgVyAtIHdlaWdodHNbbiAtIDFdLCBuIC0gMSksCiAgICAgICAgICAgICAgICAgICAgICAgIEtuYXBzYWNrKHdlaWdodHMsIHZhbHVlcywgVywgbiAtIDEpKTsKfQ=="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>public int Knapsack(int[] weights, int[] values, int W, int n)
{
    if (n == 0 || W == 0)
        return 0;
    if (weights[n - 1] &gt; W)
        return Knapsack(weights, values, W, n - 1);
    else
        return Math.Max(values[n - 1] + Knapsack(weights, values, W - weights[n - 1], n - 1),
                        Knapsack(weights, values, W, n - 1));
}</pre></div><div class='content'><ul>
<li><strong>Explanation</strong>: This approach is simple but inefficient due to the exponential time complexity.</li>
</ul>
</div><h2>Dynamic Programming Approach</h2>
<div class='content'></div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("cHVibGljIGludCBLbmFwc2FjayhpbnRbXSB3ZWlnaHRzLCBpbnRbXSB2YWx1ZXMsIGludCBXKQp7CiAgICBpbnQgbiA9IHdlaWdodHMuTGVuZ3RoOwogICAgaW50WyxdIGRwID0gbmV3IGludFtuICsgMSwgVyArIDFdOwoKICAgIGZvciAoaW50IGkgPSAwOyBpIDw9IG47IGkrKykKICAgIHsKICAgICAgICBmb3IgKGludCB3ID0gMDsgdyA8PSBXOyB3KyspCiAgICAgICAgewogICAgICAgICAgICBpZiAoaSA9PSAwIHx8IHcgPT0gMCkKICAgICAgICAgICAgICAgIGRwW2ksIHddID0gMDsKICAgICAgICAgICAgZWxzZSBpZiAod2VpZ2h0c1tpIC0gMV0gPD0gdykKICAgICAgICAgICAgICAgIGRwW2ksIHddID0gTWF0aC5NYXgodmFsdWVzW2kgLSAxXSArIGRwW2kgLSAxLCB3IC0gd2VpZ2h0c1tpIC0gMV1dLCBkcFtpIC0gMSwgd10pOwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICBkcFtpLCB3XSA9IGRwW2kgLSAxLCB3XTsKICAgICAgICB9CiAgICB9CiAgICByZXR1cm4gZHBbbiwgV107Cn0KCi8vIFVzYWdlCmludFtdIHdlaWdodHMgPSB7IDEsIDIsIDMsIDgsIDcsIDQgfTsKaW50W10gdmFsdWVzID0geyAyMCwgNSwgMTAsIDQwLCAxNSwgMjUgfTsKaW50IFcgPSAxMDsKaW50IHJlc3VsdCA9IEtuYXBzYWNrKHdlaWdodHMsIHZhbHVlcywgVyk7CkNvbnNvbGUuV3JpdGVMaW5lKHJlc3VsdCk7IC8vIE91dHB1dDogNjA="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>public int Knapsack(int[] weights, int[] values, int W)
{
    int n = weights.Length;
    int[,] dp = new int[n + 1, W + 1];

    for (int i = 0; i &lt;= n; i++)
    {
        for (int w = 0; w &lt;= W; w++)
        {
            if (i == 0 || w == 0)
                dp[i, w] = 0;
            else if (weights[i - 1] &lt;= w)
                dp[i, w] = Math.Max(values[i - 1] + dp[i - 1, w - weights[i - 1]], dp[i - 1, w]);
            else
                dp[i, w] = dp[i - 1, w];
        }
    }
    return dp[n, W];
}

// Usage
int[] weights = { 1, 2, 3, 8, 7, 4 };
int[] values = { 20, 5, 10, 40, 15, 25 };
int W = 10;
int result = Knapsack(weights, values, W);
Console.WriteLine(result); // Output: 60</pre></div><div class='content'><ul>
<li><strong>Explanation</strong>: This approach uses a 2D array to store the maximum value that can be obtained for each subproblem, resulting in a polynomial time complexity.</li>
</ul>
</div><h1>Conclusion</h1>
<div class='content'><p>Dynamic Programming is a crucial technique for solving optimization problems efficiently. By understanding and applying the concepts of overlapping subproblems, optimal substructure, memoization, and tabulation, you can tackle a wide range of problems in C#. Practice with various problems to strengthen your understanding and proficiency in Dynamic Programming.</p>
</div><div class='row navigation'>
	<div class='col-4'>
					<a href='reflection'>&#x25C4;Reflection</a>
			</div>
	<div class='col-4 text-center'>
		<a href="./" class="title">Dynamic Programming in C#</a>
	</div>
	<div class='col-4 text-end'>
					<a href='memory-management'>Memory Management and Garbage Collection &#x25BA;</a>
			</div>
</div>
</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Advertising</h1>
			<p>This space is reserved for advertising.</p>
			<p>If you want to be a sponsor, contact us to include links in this area: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>Thank you for collaborating!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. All rights reserved</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Accept</a>
    <a href="/cookies">More Information</a>
</div>	

	</div>    
</body>
</html>
