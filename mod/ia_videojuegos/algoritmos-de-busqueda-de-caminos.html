<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinding Algorithms</title>

    <link rel="alternate" href="https://campusempresa.com/mod/ia_videojuegos/algoritmos-de-busqueda-de-caminos" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/ia_videojuegos/algoritmos-de-busqueda-de-caminos" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/ia_videojuegos/algoritmos-de-busqueda-de-caminos" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo-header_enterprise.png"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Building today's and tomorrow's society</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
													<b id="lit_lang_es" class="px-2">EN</b>
				|
				<a href="https://campusempresa.com/mod/ia_videojuegos/algoritmos-de-busqueda-de-caminos" class="px-2">ES</a></b>
				|
				<a href="https://campusempresa.cat/mod/ia_videojuegos/algoritmos-de-busqueda-de-caminos" class="px-2">CA</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/objective">The Project</a>
				<a href="/about">About Us</a>
				<a href="/contribute">Contribute</a>
				<a href="/donate">Donations</a>
				<a href="/licence">License</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='content'></div><h1>Introduction</h1>
<div class='content'><p>In video game development, pathfinding algorithms are fundamental for the artificial intelligence (AI) of non-playable characters (NPCs). These algorithms allow NPCs to find the most efficient route from a starting point to a destination, avoiding obstacles and optimizing travel time.</p>
</div><h1>Key Concepts</h1>
<div class='content'><ul>
<li><strong>Graph</strong>: Abstract representation of a set of nodes (or vertices) and the connections (or edges) between them.</li>
<li><strong>Node</strong>: Point in the graph that represents a position in the game space.</li>
<li><strong>Edge</strong>: Connection between two nodes that may have an associated cost.</li>
<li><strong>Cost</strong>: Value that represents the &quot;difficulty&quot; or &quot;distance&quot; to move from one node to another.</li>
<li><strong>Heuristic</strong>: Estimation of the remaining cost from a node to the destination.</li>
</ul>
</div><h1>Pathfinding Algorithms</h1>
<div class='content'></div><h2>Breadth-First Search (BFS)</h2>
<div class='content'><p>The BFS algorithm explores all nodes at the same distance from the initial node before moving on to nodes at a greater distance. It is useful for finding the shortest path in unweighted graphs.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZnJvbSBjb2xsZWN0aW9ucyBpbXBvcnQgZGVxdWUKCmRlZiBiZnMoZ3JhcGgsIHN0YXJ0LCBnb2FsKToKICAgIHF1ZXVlID0gZGVxdWUoW3N0YXJ0XSkKICAgIHZpc2l0ZWQgPSBzZXQoKQogICAgcGFyZW50ID0ge3N0YXJ0OiBOb25lfQoKICAgIHdoaWxlIHF1ZXVlOgogICAgICAgIGN1cnJlbnQgPSBxdWV1ZS5wb3BsZWZ0KCkKICAgICAgICBpZiBjdXJyZW50ID09IGdvYWw6CiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgZm9yIG5laWdoYm9yIGluIGdyYXBoW2N1cnJlbnRdOgogICAgICAgICAgICBpZiBuZWlnaGJvciBub3QgaW4gdmlzaXRlZDoKICAgICAgICAgICAgICAgIHZpc2l0ZWQuYWRkKG5laWdoYm9yKQogICAgICAgICAgICAgICAgcGFyZW50W25laWdoYm9yXSA9IGN1cnJlbnQKICAgICAgICAgICAgICAgIHF1ZXVlLmFwcGVuZChuZWlnaGJvcikKCiAgICBwYXRoID0gW10KICAgIHdoaWxlIGN1cnJlbnQ6CiAgICAgICAgcGF0aC5hcHBlbmQoY3VycmVudCkKICAgICAgICBjdXJyZW50ID0gcGFyZW50W2N1cnJlbnRdCiAgICBwYXRoLnJldmVyc2UoKQogICAgcmV0dXJuIHBhdGg="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>from collections import deque

def bfs(graph, start, goal):
    queue = deque([start])
    visited = set()
    parent = {start: None}

    while queue:
        current = queue.popleft()
        if current == goal:
            break
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = current
                queue.append(neighbor)

    path = []
    while current:
        path.append(current)
        current = parent[current]
    path.reverse()
    return path</pre></div><div class='content'></div><h2>Depth-First Search (DFS)</h2>
<div class='content'><p>The DFS algorithm explores as far as possible along each branch before backtracking. It is useful for exploring all possible routes, although it does not guarantee the shortest path.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGRmcyhncmFwaCwgc3RhcnQsIGdvYWwpOgogICAgc3RhY2sgPSBbc3RhcnRdCiAgICB2aXNpdGVkID0gc2V0KCkKICAgIHBhcmVudCA9IHtzdGFydDogTm9uZX0KCiAgICB3aGlsZSBzdGFjazoKICAgICAgICBjdXJyZW50ID0gc3RhY2sucG9wKCkKICAgICAgICBpZiBjdXJyZW50ID09IGdvYWw6CiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgZm9yIG5laWdoYm9yIGluIGdyYXBoW2N1cnJlbnRdOgogICAgICAgICAgICBpZiBuZWlnaGJvciBub3QgaW4gdmlzaXRlZDoKICAgICAgICAgICAgICAgIHZpc2l0ZWQuYWRkKG5laWdoYm9yKQogICAgICAgICAgICAgICAgcGFyZW50W25laWdoYm9yXSA9IGN1cnJlbnQKICAgICAgICAgICAgICAgIHN0YWNrLmFwcGVuZChuZWlnaGJvcikKCiAgICBwYXRoID0gW10KICAgIHdoaWxlIGN1cnJlbnQ6CiAgICAgICAgcGF0aC5hcHBlbmQoY3VycmVudCkKICAgICAgICBjdXJyZW50ID0gcGFyZW50W2N1cnJlbnRdCiAgICBwYXRoLnJldmVyc2UoKQogICAgcmV0dXJuIHBhdGg="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def dfs(graph, start, goal):
    stack = [start]
    visited = set()
    parent = {start: None}

    while stack:
        current = stack.pop()
        if current == goal:
            break
        for neighbor in graph[current]:
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = current
                stack.append(neighbor)

    path = []
    while current:
        path.append(current)
        current = parent[current]
    path.reverse()
    return path</pre></div><div class='content'></div><h2>Dijkstra's Algorithm</h2>
<div class='content'><p>Dijkstra's algorithm finds the shortest path from a starting node to all other nodes in a weighted graph.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW1wb3J0IGhlYXBxCgpkZWYgZGlqa3N0cmEoZ3JhcGgsIHN0YXJ0LCBnb2FsKToKICAgIHF1ZXVlID0gWygwLCBzdGFydCldCiAgICBkaXN0YW5jZXMgPSB7c3RhcnQ6IDB9CiAgICBwYXJlbnQgPSB7c3RhcnQ6IE5vbmV9CgogICAgd2hpbGUgcXVldWU6CiAgICAgICAgY3VycmVudF9kaXN0YW5jZSwgY3VycmVudF9ub2RlID0gaGVhcHEuaGVhcHBvcChxdWV1ZSkKICAgICAgICBpZiBjdXJyZW50X25vZGUgPT0gZ29hbDoKICAgICAgICAgICAgYnJlYWsKICAgICAgICBmb3IgbmVpZ2hib3IsIHdlaWdodCBpbiBncmFwaFtjdXJyZW50X25vZGVdLml0ZW1zKCk6CiAgICAgICAgICAgIGRpc3RhbmNlID0gY3VycmVudF9kaXN0YW5jZSArIHdlaWdodAogICAgICAgICAgICBpZiBuZWlnaGJvciBub3QgaW4gZGlzdGFuY2VzIG9yIGRpc3RhbmNlIDwgZGlzdGFuY2VzW25laWdoYm9yXToKICAgICAgICAgICAgICAgIGRpc3RhbmNlc1tuZWlnaGJvcl0gPSBkaXN0YW5jZQogICAgICAgICAgICAgICAgcGFyZW50W25laWdoYm9yXSA9IGN1cnJlbnRfbm9kZQogICAgICAgICAgICAgICAgaGVhcHEuaGVhcHB1c2gocXVldWUsIChkaXN0YW5jZSwgbmVpZ2hib3IpKQoKICAgIHBhdGggPSBbXQogICAgY3VycmVudCA9IGdvYWwKICAgIHdoaWxlIGN1cnJlbnQ6CiAgICAgICAgcGF0aC5hcHBlbmQoY3VycmVudCkKICAgICAgICBjdXJyZW50ID0gcGFyZW50W2N1cnJlbnRdCiAgICBwYXRoLnJldmVyc2UoKQogICAgcmV0dXJuIHBhdGg="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>import heapq

def dijkstra(graph, start, goal):
    queue = [(0, start)]
    distances = {start: 0}
    parent = {start: None}

    while queue:
        current_distance, current_node = heapq.heappop(queue)
        if current_node == goal:
            break
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            if neighbor not in distances or distance &lt; distances[neighbor]:
                distances[neighbor] = distance
                parent[neighbor] = current_node
                heapq.heappush(queue, (distance, neighbor))

    path = []
    current = goal
    while current:
        path.append(current)
        current = parent[current]
    path.reverse()
    return path</pre></div><div class='content'></div><h2>A* Algorithm</h2>
<div class='content'><p>The A* algorithm combines the advantages of Dijkstra and BFS, using a heuristic to guide the search and find the shortest path efficiently.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW1wb3J0IGhlYXBxCgpkZWYgaGV1cmlzdGljKGEsIGIpOgogICAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgKyBhYnMoYVsxXSAtIGJbMV0pCgpkZWYgYV9zdGFyKGdyYXBoLCBzdGFydCwgZ29hbCk6CiAgICBxdWV1ZSA9IFsoMCwgc3RhcnQpXQogICAgZ19jb3N0cyA9IHtzdGFydDogMH0KICAgIGZfY29zdHMgPSB7c3RhcnQ6IGhldXJpc3RpYyhzdGFydCwgZ29hbCl9CiAgICBwYXJlbnQgPSB7c3RhcnQ6IE5vbmV9CgogICAgd2hpbGUgcXVldWU6CiAgICAgICAgXywgY3VycmVudCA9IGhlYXBxLmhlYXBwb3AocXVldWUpCiAgICAgICAgaWYgY3VycmVudCA9PSBnb2FsOgogICAgICAgICAgICBicmVhawogICAgICAgIGZvciBuZWlnaGJvciwgd2VpZ2h0IGluIGdyYXBoW2N1cnJlbnRdLml0ZW1zKCk6CiAgICAgICAgICAgIHRlbnRhdGl2ZV9nX2Nvc3QgPSBnX2Nvc3RzW2N1cnJlbnRdICsgd2VpZ2h0CiAgICAgICAgICAgIGlmIG5laWdoYm9yIG5vdCBpbiBnX2Nvc3RzIG9yIHRlbnRhdGl2ZV9nX2Nvc3QgPCBnX2Nvc3RzW25laWdoYm9yXToKICAgICAgICAgICAgICAgIGdfY29zdHNbbmVpZ2hib3JdID0gdGVudGF0aXZlX2dfY29zdAogICAgICAgICAgICAgICAgZl9jb3N0c1tuZWlnaGJvcl0gPSB0ZW50YXRpdmVfZ19jb3N0ICsgaGV1cmlzdGljKG5laWdoYm9yLCBnb2FsKQogICAgICAgICAgICAgICAgcGFyZW50W25laWdoYm9yXSA9IGN1cnJlbnQKICAgICAgICAgICAgICAgIGhlYXBxLmhlYXBwdXNoKHF1ZXVlLCAoZl9jb3N0c1tuZWlnaGJvcl0sIG5laWdoYm9yKSkKCiAgICBwYXRoID0gW10KICAgIGN1cnJlbnQgPSBnb2FsCiAgICB3aGlsZSBjdXJyZW50OgogICAgICAgIHBhdGguYXBwZW5kKGN1cnJlbnQpCiAgICAgICAgY3VycmVudCA9IHBhcmVudFtjdXJyZW50XQogICAgcGF0aC5yZXZlcnNlKCkKICAgIHJldHVybiBwYXRo"))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>import heapq

def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def a_star(graph, start, goal):
    queue = [(0, start)]
    g_costs = {start: 0}
    f_costs = {start: heuristic(start, goal)}
    parent = {start: None}

    while queue:
        _, current = heapq.heappop(queue)
        if current == goal:
            break
        for neighbor, weight in graph[current].items():
            tentative_g_cost = g_costs[current] + weight
            if neighbor not in g_costs or tentative_g_cost &lt; g_costs[neighbor]:
                g_costs[neighbor] = tentative_g_cost
                f_costs[neighbor] = tentative_g_cost + heuristic(neighbor, goal)
                parent[neighbor] = current
                heapq.heappush(queue, (f_costs[neighbor], neighbor))

    path = []
    current = goal
    while current:
        path.append(current)
        current = parent[current]
    path.reverse()
    return path</pre></div><div class='content'></div><h1>Algorithm Comparison</h1>
<div class='content'><p>| Algorithm  | Complexity | Ideal Use                          | Advantages                       | Disadvantages                    |
|------------|-------------|------------------------------------|----------------------------------|----------------------------------|
| BFS        | O(V + E)    | Unweighted graphs                  | Finds the shortest path          | Not efficient in large graphs    |
| DFS        | O(V + E)    | Complete exploration               | Simple to implement              | Does not guarantee the shortest path |
| Dijkstra   | O(V^2)      | Weighted graphs                    | Finds the shortest path          | Slow in dense graphs             |
| A*         | O(E)        | Weighted graphs with heuristic     | Fast and efficient               | Depends on the heuristic         |</p>
</div><h1>Conclusion</h1>
<div class='content'><p>Pathfinding algorithms are essential for AI in video games, allowing NPCs to navigate efficiently and realistically. Each algorithm has its own advantages and disadvantages, and the choice of the appropriate algorithm depends on the game's context and specific performance and accuracy requirements.</p>
</div></div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Advertising</h1>
			<p>This space is reserved for advertising.</p>
			<p>If you want to be a sponsor, contact us to include links in this area: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>Thank you for collaborating!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. All rights reserved</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Accept</a>
    <a href="/cookies">More Information</a>
</div>	

	</div>    
</body>
</html>
