<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shortest Path Algorithms</title>

    <link rel="alternate" href="https://campusempresa.com/mod/algoritmos_avanzados/algoritmos-de-caminos-minimos" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/algoritmos_avanzados/algoritmos-de-caminos-minimos" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/algoritmos_avanzados/algoritmos-de-caminos-minimos" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body  class="test" >
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo-header_enterprise.png"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Building today's and tomorrow's society</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
													<b id="lit_lang_es" class="px-2">EN</b>
				|
				<a href="https://campusempresa.com/mod/algoritmos_avanzados/algoritmos-de-caminos-minimos" class="px-2">ES</a></b>
				|
				<a href="https://campusempresa.cat/mod/algoritmos_avanzados/algoritmos-de-caminos-minimos" class="px-2">CA</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/objective">The Project</a>
				<a href="/about">About Us</a>
				<a href="/contribute">Contribute</a>
				<a href="/donate">Donations</a>
				<a href="/licence">License</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content">
									<div class="assert">
						<p><b>Attention!</b> There has been an error in the course generation, and it may contain translation errors.We are working to resolve this issue, so please use the content with caution.You can check the correct content in another language at the following link:<br>
						<a href="https://campusempresa.com/mod/algoritmos_avanzados/algoritmos-de-caminos-minimos">https://campusempresa.com/mod/algoritmos_avanzados/algoritmos-de-caminos-minimos</a></p>
					</div>
								<div class='content'></div><h1>Introduction</h1>
<div class='content'><p>Shortest path algorithms are fundamental in graph theory and have applications in various areas such as network optimization, route planning, and artificial intelligence. This topic covers the most important algorithms for finding shortest paths in weighted and unweighted graphs.</p>
</div><h1>Key Concepts</h1>
<div class='content'><ul>
<li><strong>Graph</strong>: A structure composed of nodes (or vertices) and edges (or arcs) that connect pairs of nodes.</li>
<li><strong>Weight</strong>: A value associated with an edge that can represent distance, cost, time, etc.</li>
<li><strong>Shortest Path</strong>: The route between two nodes in a graph that has the smallest total weight.</li>
</ul>
</div><h1>Main Algorithms</h1>
<div class='content'></div><h2>Dijkstra's Algorithm</h2>
<div class='content'><p>Dijkstra's algorithm is one of the most well-known for finding the shortest path from a source node to all other nodes in a graph with non-negative weights.</p>
<h4>Algorithm Steps</h4>
<ol>
<li>Initialize the distance to the source node as 0 and to all other nodes as infinity.</li>
<li>Mark all nodes as unvisited.</li>
<li>Select the unvisited node with the smallest distance.</li>
<li>Update the distance of the adjacent nodes.</li>
<li>Mark the current node as visited.</li>
<li>Repeat steps 3-5 until all nodes have been visited.</li>
</ol>
<h4>Code Example</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW1wb3J0IGhlYXBxCgpkZWYgZGlqa3N0cmEoZ3JhcGgsIHN0YXJ0KToKICAgICMgSW5pdGlhbGl6ZSBkaXN0YW5jZXMgYW5kIHByaW9yaXR5IHF1ZXVlCiAgICBkaXN0YW5jZXMgPSB7dmVydGV4OiBmbG9hdCgnaW5maW5pdHknKSBmb3IgdmVydGV4IGluIGdyYXBofQogICAgZGlzdGFuY2VzW3N0YXJ0XSA9IDAKICAgIHByaW9yaXR5X3F1ZXVlID0gWygwLCBzdGFydCldCiAgICAKICAgIHdoaWxlIHByaW9yaXR5X3F1ZXVlOgogICAgICAgIGN1cnJlbnRfZGlzdGFuY2UsIGN1cnJlbnRfdmVydGV4ID0gaGVhcHEuaGVhcHBvcChwcmlvcml0eV9xdWV1ZSkKICAgICAgICAKICAgICAgICBpZiBjdXJyZW50X2Rpc3RhbmNlID4gZGlzdGFuY2VzW2N1cnJlbnRfdmVydGV4XToKICAgICAgICAgICAgY29udGludWUKICAgICAgICAKICAgICAgICBmb3IgbmVpZ2hib3IsIHdlaWdodCBpbiBncmFwaFtjdXJyZW50X3ZlcnRleF0uaXRlbXMoKToKICAgICAgICAgICAgZGlzdGFuY2UgPSBjdXJyZW50X2Rpc3RhbmNlICsgd2VpZ2h0CiAgICAgICAgICAgIAogICAgICAgICAgICBpZiBkaXN0YW5jZSA8IGRpc3RhbmNlc1tuZWlnaGJvcl06CiAgICAgICAgICAgICAgICBkaXN0YW5jZXNbbmVpZ2hib3JdID0gZGlzdGFuY2UKICAgICAgICAgICAgICAgIGhlYXBxLmhlYXBwdXNoKHByaW9yaXR5X3F1ZXVlLCAoZGlzdGFuY2UsIG5laWdoYm9yKSkKICAgIAogICAgcmV0dXJuIGRpc3RhbmNlcwoKIyBVc2FnZSBleGFtcGxlCmdyYXBoID0gewogICAgJ0EnOiB7J0InOiAxLCAnQyc6IDR9LAogICAgJ0InOiB7J0EnOiAxLCAnQyc6IDIsICdEJzogNX0sCiAgICAnQyc6IHsnQSc6IDQsICdCJzogMiwgJ0QnOiAxfSwKICAgICdEJzogeydCJzogNSwgJ0MnOiAxfQp9CgpwcmludChkaWprc3RyYShncmFwaCwgJ0EnKSk="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>import heapq

def dijkstra(graph, start):
    # Initialize distances and priority queue
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    priority_queue = [(0, start)]
    
    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)
        
        if current_distance &gt; distances[current_vertex]:
            continue
        
        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            
            if distance &lt; distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances

# Usage example
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

print(dijkstra(graph, 'A'))</pre></div><div class='content'></div><h2>Bellman-Ford Algorithm</h2>
<div class='content'><p>The Bellman-Ford algorithm can handle graphs with negative weights and can also detect negative cycles.</p>
<h4>Algorithm Steps</h4>
<ol>
<li>Initialize the distance to the source node as 0 and to all other nodes as infinity.</li>
<li>Relax all edges of the graph repeatedly.</li>
<li>Check for negative cycles.</li>
</ol>
<h4>Code Example</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGJlbGxtYW5fZm9yZChncmFwaCwgc3RhcnQpOgogICAgZGlzdGFuY2VzID0ge3ZlcnRleDogZmxvYXQoJ2luZmluaXR5JykgZm9yIHZlcnRleCBpbiBncmFwaH0KICAgIGRpc3RhbmNlc1tzdGFydF0gPSAwCiAgICAKICAgIGZvciBfIGluIHJhbmdlKGxlbihncmFwaCkgLSAxKToKICAgICAgICBmb3IgdmVydGV4IGluIGdyYXBoOgogICAgICAgICAgICBmb3IgbmVpZ2hib3IsIHdlaWdodCBpbiBncmFwaFt2ZXJ0ZXhdLml0ZW1zKCk6CiAgICAgICAgICAgICAgICBpZiBkaXN0YW5jZXNbdmVydGV4XSArIHdlaWdodCA8IGRpc3RhbmNlc1tuZWlnaGJvcl06CiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VzW25laWdoYm9yXSA9IGRpc3RhbmNlc1t2ZXJ0ZXhdICsgd2VpZ2h0CiAgICAKICAgICMgTmVnYXRpdmUgY3ljbGUgY2hlY2sKICAgIGZvciB2ZXJ0ZXggaW4gZ3JhcGg6CiAgICAgICAgZm9yIG5laWdoYm9yLCB3ZWlnaHQgaW4gZ3JhcGhbdmVydGV4XS5pdGVtcygpOgogICAgICAgICAgICBpZiBkaXN0YW5jZXNbdmVydGV4XSArIHdlaWdodCA8IGRpc3RhbmNlc1tuZWlnaGJvcl06CiAgICAgICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCJHcmFwaCBjb250YWlucyBhIG5lZ2F0aXZlLXdlaWdodCBjeWNsZSIpCiAgICAKICAgIHJldHVybiBkaXN0YW5jZXMKCiMgVXNhZ2UgZXhhbXBsZQpncmFwaCA9IHsKICAgICdBJzogeydCJzogMSwgJ0MnOiA0fSwKICAgICdCJzogeydDJzogLTMsICdEJzogMn0sCiAgICAnQyc6IHsnRCc6IDN9LAogICAgJ0QnOiB7fQp9CgpwcmludChiZWxsbWFuX2ZvcmQoZ3JhcGgsICdBJykp"))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def bellman_ford(graph, start):
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    
    for _ in range(len(graph) - 1):
        for vertex in graph:
            for neighbor, weight in graph[vertex].items():
                if distances[vertex] + weight &lt; distances[neighbor]:
                    distances[neighbor] = distances[vertex] + weight
    
    # Negative cycle check
    for vertex in graph:
        for neighbor, weight in graph[vertex].items():
            if distances[vertex] + weight &lt; distances[neighbor]:
                raise ValueError(&quot;Graph contains a negative-weight cycle&quot;)
    
    return distances

# Usage example
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'C': -3, 'D': 2},
    'C': {'D': 3},
    'D': {}
}

print(bellman_ford(graph, 'A'))</pre></div><div class='content'></div><h2>Floyd-Warshall Algorithm</h2>
<div class='content'><p>The Floyd-Warshall algorithm finds shortest paths between all pairs of nodes in a graph.</p>
<h4>Algorithm Steps</h4>
<ol>
<li>Create a distance matrix initialized with the weights of the edges.</li>
<li>Iterate over all pairs of nodes and update the minimum distances.</li>
</ol>
<h4>Code Example</h4>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGZsb3lkX3dhcnNoYWxsKGdyYXBoKToKICAgIG5vZGVzID0gbGlzdChncmFwaC5rZXlzKCkpCiAgICBkaXN0ID0ge25vZGU6IHtub2RlOiBmbG9hdCgnaW5maW5pdHknKSBmb3Igbm9kZSBpbiBub2Rlc30gZm9yIG5vZGUgaW4gbm9kZXN9CiAgICAKICAgIGZvciBub2RlIGluIG5vZGVzOgogICAgICAgIGRpc3Rbbm9kZV1bbm9kZV0gPSAwCiAgICAgICAgZm9yIG5laWdoYm9yLCB3ZWlnaHQgaW4gZ3JhcGhbbm9kZV0uaXRlbXMoKToKICAgICAgICAgICAgZGlzdFtub2RlXVtuZWlnaGJvcl0gPSB3ZWlnaHQKICAgIAogICAgZm9yIGsgaW4gbm9kZXM6CiAgICAgICAgZm9yIGkgaW4gbm9kZXM6CiAgICAgICAgICAgIGZvciBqIGluIG5vZGVzOgogICAgICAgICAgICAgICAgZGlzdFtpXVtqXSA9IG1pbihkaXN0W2ldW2pdLCBkaXN0W2ldW2tdICsgZGlzdFtrXVtqXSkKICAgIAogICAgcmV0dXJuIGRpc3QKCiMgVXNhZ2UgZXhhbXBsZQpncmFwaCA9IHsKICAgICdBJzogeydCJzogMSwgJ0MnOiA0fSwKICAgICdCJzogeydDJzogMiwgJ0QnOiA1fSwKICAgICdDJzogeydEJzogMX0sCiAgICAnRCc6IHt9Cn0KCnByaW50KGZsb3lkX3dhcnNoYWxsKGdyYXBoKSk="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def floyd_warshall(graph):
    nodes = list(graph.keys())
    dist = {node: {node: float('infinity') for node in nodes} for node in nodes}
    
    for node in nodes:
        dist[node][node] = 0
        for neighbor, weight in graph[node].items():
            dist[node][neighbor] = weight
    
    for k in nodes:
        for i in nodes:
            for j in nodes:
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
    
    return dist

# Usage example
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'C': 2, 'D': 5},
    'C': {'D': 1},
    'D': {}
}

print(floyd_warshall(graph))</pre></div><div class='content'></div><h1>Algorithm Comparison</h1>
<div class='content'><p>| Algorithm       | Time Complexity       | Handles Negative Weights | Detects Negative Cycles |
|-----------------|-----------------------|--------------------------|--------------------------|
| Dijkstra        | O(V^2) or O(E + V log V) with heap | No                     | No                       |
| Bellman-Ford    | O(VE)                 | Yes                     | Yes                       |
| Floyd-Warshall  | O(V^3)                | Yes                     | No                       |</p>
</div><h1>Conclusion</h1>
<div class='content'><p>Shortest path algorithms are essential tools in graph theory and have practical applications in various areas. Dijkstra is efficient for graphs with non-negative weights, Bellman-Ford handles negative weights and detects negative cycles, and Floyd-Warshall is useful for finding shortest paths between all pairs of nodes. The choice of the appropriate algorithm depends on the characteristics of the graph and the specific requirements of the problem to be solved.</p>
</div>
			</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Advertising</h1>
			<p>This space is reserved for advertising.</p>
			<p>If you want to be a sponsor, contact us to include links in this area: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>Thank you for collaborating!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. All rights reserved</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Accept</a>
    <a href="/cookies">More Information</a>
</div>	

	</div>    
</body>
</html>
