<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphs in C</title>

    <link rel="alternate" href="https://campusempresa.com/mod/c/graphs" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/c/graphs" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/c/graphs" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body >
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo-header_enterprise.png"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Building today's and tomorrow's society</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
													<b id="lit_lang_es" class="px-2">EN</b>
				|
				<a href="https://campusempresa.com/mod/c/graphs" class="px-2">ES</a></b>
				|
				<a href="https://campusempresa.cat/mod/c/graphs" class="px-2">CA</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/objective">The Project</a>
				<a href="/about">About Us</a>
				<a href="/contribute">Contribute</a>
				<a href="/donate">Donations</a>
				<a href="/licence">License</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content">
								<div class='row navigation'>
	<div class='col-4'>
					<a href='trees'>&#x25C4;Trees</a>
			</div>
	<div class='col-4 text-center'>
		<a href="./" class="title">Graphs in C</a>
	</div>
	<div class='col-4 text-end'>
					<a href='debugging-techniques'>Debugging Techniques &#x25BA;</a>
			</div>
</div>
<div class='content'><p>Graphs are a fundamental data structure in computer science, used to model pairwise relations between objects. This topic will guide you through understanding, implementing, and utilizing graphs in C, from basic concepts to advanced techniques.</p>
</div><h1>Introduction to Graphs</h1>
<div class='content'><p>Graphs consist of nodes (also called vertices) and edges that connect pairs of nodes. They can be used to represent various real-world structures like social networks, transportation systems, and more.</p>
<ul>
<li><strong>Vertices (Nodes)</strong>: The fundamental units of a graph.</li>
<li><strong>Edges</strong>: The connections between the vertices.</li>
<li><strong>Directed Graphs (Digraphs)</strong>: Graphs where edges have a direction.</li>
<li><strong>Undirected Graphs</strong>: Graphs where edges do not have a direction.</li>
<li><strong>Weighted Graphs</strong>: Graphs where edges have weights (costs).</li>
</ul>
</div><h1>Representing Graphs in C</h1>
<div class='content'><p>There are several ways to represent graphs in C, each with its own advantages and use cases.</p>
</div><h2>Adjacency Matrix</h2>
<div class='content'><p>An adjacency matrix is a 2D array where the element at row <code>i</code> and column <code>j</code> indicates whether there is an edge from vertex <code>i</code> to vertex <code>j</code>.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I2luY2x1ZGUgPHN0ZGlvLmg+CgojZGVmaW5lIFYgNAoKdm9pZCBwcmludE1hdHJpeChpbnQgZ3JhcGhbVl1bVl0pIHsKICAgIGZvciAoaW50IGkgPSAwOyBpIDwgVjsgaSsrKSB7CiAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBWOyBqKyspIHsKICAgICAgICAgICAgcHJpbnRmKCIlZCAiLCBncmFwaFtpXVtqXSk7CiAgICAgICAgfQogICAgICAgIHByaW50ZigiXG4iKTsKICAgIH0KfQoKaW50IG1haW4oKSB7CiAgICBpbnQgZ3JhcGhbVl1bVl0gPSB7CiAgICAgICAgezAsIDEsIDAsIDB9LAogICAgICAgIHsxLCAwLCAxLCAxfSwKICAgICAgICB7MCwgMSwgMCwgMX0sCiAgICAgICAgezAsIDEsIDEsIDB9CiAgICB9OwoKICAgIHByaW50TWF0cml4KGdyYXBoKTsKICAgIHJldHVybiAwOwp9"))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#include &lt;stdio.h&gt;

#define V 4

void printMatrix(int graph[V][V]) {
    for (int i = 0; i &lt; V; i++) {
        for (int j = 0; j &lt; V; j++) {
            printf(&quot;%d &quot;, graph[i][j]);
        }
        printf(&quot;\n&quot;);
    }
}

int main() {
    int graph[V][V] = {
        {0, 1, 0, 0},
        {1, 0, 1, 1},
        {0, 1, 0, 1},
        {0, 1, 1, 0}
    };

    printMatrix(graph);
    return 0;
}</pre></div><div class='content'></div><h2>Adjacency List</h2>
<div class='content'><p>An adjacency list is an array of linked lists. The array index represents a vertex, and each element in the linked list represents the vertices connected to it.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I2luY2x1ZGUgPHN0ZGlvLmg+CiNpbmNsdWRlIDxzdGRsaWIuaD4KCnN0cnVjdCBOb2RlIHsKICAgIGludCB2ZXJ0ZXg7CiAgICBzdHJ1Y3QgTm9kZSogbmV4dDsKfTsKCnN0cnVjdCBHcmFwaCB7CiAgICBpbnQgbnVtVmVydGljZXM7CiAgICBzdHJ1Y3QgTm9kZSoqIGFkakxpc3RzOwp9OwoKc3RydWN0IE5vZGUqIGNyZWF0ZU5vZGUoaW50IHYpIHsKICAgIHN0cnVjdCBOb2RlKiBuZXdOb2RlID0gbWFsbG9jKHNpemVvZihzdHJ1Y3QgTm9kZSkpOwogICAgbmV3Tm9kZS0+dmVydGV4ID0gdjsKICAgIG5ld05vZGUtPm5leHQgPSBOVUxMOwogICAgcmV0dXJuIG5ld05vZGU7Cn0KCnN0cnVjdCBHcmFwaCogY3JlYXRlR3JhcGgoaW50IHZlcnRpY2VzKSB7CiAgICBzdHJ1Y3QgR3JhcGgqIGdyYXBoID0gbWFsbG9jKHNpemVvZihzdHJ1Y3QgR3JhcGgpKTsKICAgIGdyYXBoLT5udW1WZXJ0aWNlcyA9IHZlcnRpY2VzOwogICAgZ3JhcGgtPmFkakxpc3RzID0gbWFsbG9jKHZlcnRpY2VzICogc2l6ZW9mKHN0cnVjdCBOb2RlKikpOwoKICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXM7IGkrKykKICAgICAgICBncmFwaC0+YWRqTGlzdHNbaV0gPSBOVUxMOwoKICAgIHJldHVybiBncmFwaDsKfQoKdm9pZCBhZGRFZGdlKHN0cnVjdCBHcmFwaCogZ3JhcGgsIGludCBzcmMsIGludCBkZXN0KSB7CiAgICBzdHJ1Y3QgTm9kZSogbmV3Tm9kZSA9IGNyZWF0ZU5vZGUoZGVzdCk7CiAgICBuZXdOb2RlLT5uZXh0ID0gZ3JhcGgtPmFkakxpc3RzW3NyY107CiAgICBncmFwaC0+YWRqTGlzdHNbc3JjXSA9IG5ld05vZGU7CgogICAgbmV3Tm9kZSA9IGNyZWF0ZU5vZGUoc3JjKTsKICAgIG5ld05vZGUtPm5leHQgPSBncmFwaC0+YWRqTGlzdHNbZGVzdF07CiAgICBncmFwaC0+YWRqTGlzdHNbZGVzdF0gPSBuZXdOb2RlOwp9Cgp2b2lkIHByaW50R3JhcGgoc3RydWN0IEdyYXBoKiBncmFwaCkgewogICAgZm9yIChpbnQgdiA9IDA7IHYgPCBncmFwaC0+bnVtVmVydGljZXM7IHYrKykgewogICAgICAgIHN0cnVjdCBOb2RlKiB0ZW1wID0gZ3JhcGgtPmFkakxpc3RzW3ZdOwogICAgICAgIHByaW50ZigiXG4gVmVydGV4ICVkXG46ICIsIHYpOwogICAgICAgIHdoaWxlICh0ZW1wKSB7CiAgICAgICAgICAgIHByaW50ZigiJWQgLT4gIiwgdGVtcC0+dmVydGV4KTsKICAgICAgICAgICAgdGVtcCA9IHRlbXAtPm5leHQ7CiAgICAgICAgfQogICAgICAgIHByaW50ZigiXG4iKTsKICAgIH0KfQoKaW50IG1haW4oKSB7CiAgICBzdHJ1Y3QgR3JhcGgqIGdyYXBoID0gY3JlYXRlR3JhcGgoNCk7CiAgICBhZGRFZGdlKGdyYXBoLCAwLCAxKTsKICAgIGFkZEVkZ2UoZ3JhcGgsIDAsIDIpOwogICAgYWRkRWRnZShncmFwaCwgMSwgMik7CiAgICBhZGRFZGdlKGdyYXBoLCAyLCAzKTsKCiAgICBwcmludEdyYXBoKGdyYXBoKTsKCiAgICByZXR1cm4gMDsKfQ=="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int vertex;
    struct Node* next;
};

struct Graph {
    int numVertices;
    struct Node** adjLists;
};

struct Node* createNode(int v) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode-&gt;vertex = v;
    newNode-&gt;next = NULL;
    return newNode;
}

struct Graph* createGraph(int vertices) {
    struct Graph* graph = malloc(sizeof(struct Graph));
    graph-&gt;numVertices = vertices;
    graph-&gt;adjLists = malloc(vertices * sizeof(struct Node*));

    for (int i = 0; i &lt; vertices; i++)
        graph-&gt;adjLists[i] = NULL;

    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    struct Node* newNode = createNode(dest);
    newNode-&gt;next = graph-&gt;adjLists[src];
    graph-&gt;adjLists[src] = newNode;

    newNode = createNode(src);
    newNode-&gt;next = graph-&gt;adjLists[dest];
    graph-&gt;adjLists[dest] = newNode;
}

void printGraph(struct Graph* graph) {
    for (int v = 0; v &lt; graph-&gt;numVertices; v++) {
        struct Node* temp = graph-&gt;adjLists[v];
        printf(&quot;\n Vertex %d\n: &quot;, v);
        while (temp) {
            printf(&quot;%d -&gt; &quot;, temp-&gt;vertex);
            temp = temp-&gt;next;
        }
        printf(&quot;\n&quot;);
    }
}

int main() {
    struct Graph* graph = createGraph(4);
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 2);
    addEdge(graph, 2, 3);

    printGraph(graph);

    return 0;
}</pre></div><div class='content'></div><h1>Graph Traversal</h1>
<div class='content'><p>Graph traversal refers to the process of visiting all the nodes in a graph. The two most common methods are Depth-First Search (DFS) and Breadth-First Search (BFS).</p>
</div><h2>Depth-First Search (DFS)</h2>
<div class='content'><p>DFS explores as far as possible along each branch before backtracking.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I2luY2x1ZGUgPHN0ZGlvLmg+CiNpbmNsdWRlIDxzdGRsaWIuaD4KCnN0cnVjdCBOb2RlIHsKICAgIGludCB2ZXJ0ZXg7CiAgICBzdHJ1Y3QgTm9kZSogbmV4dDsKfTsKCnN0cnVjdCBHcmFwaCB7CiAgICBpbnQgbnVtVmVydGljZXM7CiAgICBzdHJ1Y3QgTm9kZSoqIGFkakxpc3RzOwogICAgaW50KiB2aXNpdGVkOwp9OwoKc3RydWN0IE5vZGUqIGNyZWF0ZU5vZGUoaW50IHYpIHsKICAgIHN0cnVjdCBOb2RlKiBuZXdOb2RlID0gbWFsbG9jKHNpemVvZihzdHJ1Y3QgTm9kZSkpOwogICAgbmV3Tm9kZS0+dmVydGV4ID0gdjsKICAgIG5ld05vZGUtPm5leHQgPSBOVUxMOwogICAgcmV0dXJuIG5ld05vZGU7Cn0KCnN0cnVjdCBHcmFwaCogY3JlYXRlR3JhcGgoaW50IHZlcnRpY2VzKSB7CiAgICBzdHJ1Y3QgR3JhcGgqIGdyYXBoID0gbWFsbG9jKHNpemVvZihzdHJ1Y3QgR3JhcGgpKTsKICAgIGdyYXBoLT5udW1WZXJ0aWNlcyA9IHZlcnRpY2VzOwogICAgZ3JhcGgtPmFkakxpc3RzID0gbWFsbG9jKHZlcnRpY2VzICogc2l6ZW9mKHN0cnVjdCBOb2RlKikpOwogICAgZ3JhcGgtPnZpc2l0ZWQgPSBtYWxsb2ModmVydGljZXMgKiBzaXplb2YoaW50KSk7CgogICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlczsgaSsrKSB7CiAgICAgICAgZ3JhcGgtPmFkakxpc3RzW2ldID0gTlVMTDsKICAgICAgICBncmFwaC0+dmlzaXRlZFtpXSA9IDA7CiAgICB9CgogICAgcmV0dXJuIGdyYXBoOwp9Cgp2b2lkIGFkZEVkZ2Uoc3RydWN0IEdyYXBoKiBncmFwaCwgaW50IHNyYywgaW50IGRlc3QpIHsKICAgIHN0cnVjdCBOb2RlKiBuZXdOb2RlID0gY3JlYXRlTm9kZShkZXN0KTsKICAgIG5ld05vZGUtPm5leHQgPSBncmFwaC0+YWRqTGlzdHNbc3JjXTsKICAgIGdyYXBoLT5hZGpMaXN0c1tzcmNdID0gbmV3Tm9kZTsKCiAgICBuZXdOb2RlID0gY3JlYXRlTm9kZShzcmMpOwogICAgbmV3Tm9kZS0+bmV4dCA9IGdyYXBoLT5hZGpMaXN0c1tkZXN0XTsKICAgIGdyYXBoLT5hZGpMaXN0c1tkZXN0XSA9IG5ld05vZGU7Cn0KCnZvaWQgREZTKHN0cnVjdCBHcmFwaCogZ3JhcGgsIGludCB2ZXJ0ZXgpIHsKICAgIHN0cnVjdCBOb2RlKiBhZGpMaXN0ID0gZ3JhcGgtPmFkakxpc3RzW3ZlcnRleF07CiAgICBzdHJ1Y3QgTm9kZSogdGVtcCA9IGFkakxpc3Q7CgogICAgZ3JhcGgtPnZpc2l0ZWRbdmVydGV4XSA9IDE7CiAgICBwcmludGYoIlZpc2l0ZWQgJWQgXG4iLCB2ZXJ0ZXgpOwoKICAgIHdoaWxlICh0ZW1wICE9IE5VTEwpIHsKICAgICAgICBpbnQgY29ubmVjdGVkVmVydGV4ID0gdGVtcC0+dmVydGV4OwoKICAgICAgICBpZiAoZ3JhcGgtPnZpc2l0ZWRbY29ubmVjdGVkVmVydGV4XSA9PSAwKSB7CiAgICAgICAgICAgIERGUyhncmFwaCwgY29ubmVjdGVkVmVydGV4KTsKICAgICAgICB9CiAgICAgICAgdGVtcCA9IHRlbXAtPm5leHQ7CiAgICB9Cn0KCmludCBtYWluKCkgewogICAgc3RydWN0IEdyYXBoKiBncmFwaCA9IGNyZWF0ZUdyYXBoKDQpOwogICAgYWRkRWRnZShncmFwaCwgMCwgMSk7CiAgICBhZGRFZGdlKGdyYXBoLCAwLCAyKTsKICAgIGFkZEVkZ2UoZ3JhcGgsIDEsIDIpOwogICAgYWRkRWRnZShncmFwaCwgMiwgMyk7CgogICAgREZTKGdyYXBoLCAwKTsKCiAgICByZXR1cm4gMDsKfQ=="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int vertex;
    struct Node* next;
};

struct Graph {
    int numVertices;
    struct Node** adjLists;
    int* visited;
};

struct Node* createNode(int v) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode-&gt;vertex = v;
    newNode-&gt;next = NULL;
    return newNode;
}

struct Graph* createGraph(int vertices) {
    struct Graph* graph = malloc(sizeof(struct Graph));
    graph-&gt;numVertices = vertices;
    graph-&gt;adjLists = malloc(vertices * sizeof(struct Node*));
    graph-&gt;visited = malloc(vertices * sizeof(int));

    for (int i = 0; i &lt; vertices; i++) {
        graph-&gt;adjLists[i] = NULL;
        graph-&gt;visited[i] = 0;
    }

    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    struct Node* newNode = createNode(dest);
    newNode-&gt;next = graph-&gt;adjLists[src];
    graph-&gt;adjLists[src] = newNode;

    newNode = createNode(src);
    newNode-&gt;next = graph-&gt;adjLists[dest];
    graph-&gt;adjLists[dest] = newNode;
}

void DFS(struct Graph* graph, int vertex) {
    struct Node* adjList = graph-&gt;adjLists[vertex];
    struct Node* temp = adjList;

    graph-&gt;visited[vertex] = 1;
    printf(&quot;Visited %d \n&quot;, vertex);

    while (temp != NULL) {
        int connectedVertex = temp-&gt;vertex;

        if (graph-&gt;visited[connectedVertex] == 0) {
            DFS(graph, connectedVertex);
        }
        temp = temp-&gt;next;
    }
}

int main() {
    struct Graph* graph = createGraph(4);
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 2);
    addEdge(graph, 2, 3);

    DFS(graph, 0);

    return 0;
}</pre></div><div class='content'></div><h2>Breadth-First Search (BFS)</h2>
<div class='content'><p>BFS explores all neighbors at the present depth prior to moving on to nodes at the next depth level.</p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I2luY2x1ZGUgPHN0ZGlvLmg+CiNpbmNsdWRlIDxzdGRsaWIuaD4KCnN0cnVjdCBOb2RlIHsKICAgIGludCB2ZXJ0ZXg7CiAgICBzdHJ1Y3QgTm9kZSogbmV4dDsKfTsKCnN0cnVjdCBHcmFwaCB7CiAgICBpbnQgbnVtVmVydGljZXM7CiAgICBzdHJ1Y3QgTm9kZSoqIGFkakxpc3RzOwogICAgaW50KiB2aXNpdGVkOwp9OwoKc3RydWN0IFF1ZXVlIHsKICAgIGludCBpdGVtc1sxMDBdOwogICAgaW50IGZyb250OwogICAgaW50IHJlYXI7Cn07CgpzdHJ1Y3QgTm9kZSogY3JlYXRlTm9kZShpbnQgdikgewogICAgc3RydWN0IE5vZGUqIG5ld05vZGUgPSBtYWxsb2Moc2l6ZW9mKHN0cnVjdCBOb2RlKSk7CiAgICBuZXdOb2RlLT52ZXJ0ZXggPSB2OwogICAgbmV3Tm9kZS0+bmV4dCA9IE5VTEw7CiAgICByZXR1cm4gbmV3Tm9kZTsKfQoKc3RydWN0IEdyYXBoKiBjcmVhdGVHcmFwaChpbnQgdmVydGljZXMpIHsKICAgIHN0cnVjdCBHcmFwaCogZ3JhcGggPSBtYWxsb2Moc2l6ZW9mKHN0cnVjdCBHcmFwaCkpOwogICAgZ3JhcGgtPm51bVZlcnRpY2VzID0gdmVydGljZXM7CiAgICBncmFwaC0+YWRqTGlzdHMgPSBtYWxsb2ModmVydGljZXMgKiBzaXplb2Yoc3RydWN0IE5vZGUqKSk7CiAgICBncmFwaC0+dmlzaXRlZCA9IG1hbGxvYyh2ZXJ0aWNlcyAqIHNpemVvZihpbnQpKTsKCiAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzOyBpKyspIHsKICAgICAgICBncmFwaC0+YWRqTGlzdHNbaV0gPSBOVUxMOwogICAgICAgIGdyYXBoLT52aXNpdGVkW2ldID0gMDsKICAgIH0KCiAgICByZXR1cm4gZ3JhcGg7Cn0KCnZvaWQgYWRkRWRnZShzdHJ1Y3QgR3JhcGgqIGdyYXBoLCBpbnQgc3JjLCBpbnQgZGVzdCkgewogICAgc3RydWN0IE5vZGUqIG5ld05vZGUgPSBjcmVhdGVOb2RlKGRlc3QpOwogICAgbmV3Tm9kZS0+bmV4dCA9IGdyYXBoLT5hZGpMaXN0c1tzcmNdOwogICAgZ3JhcGgtPmFkakxpc3RzW3NyY10gPSBuZXdOb2RlOwoKICAgIG5ld05vZGUgPSBjcmVhdGVOb2RlKHNyYyk7CiAgICBuZXdOb2RlLT5uZXh0ID0gZ3JhcGgtPmFkakxpc3RzW2Rlc3RdOwogICAgZ3JhcGgtPmFkakxpc3RzW2Rlc3RdID0gbmV3Tm9kZTsKfQoKc3RydWN0IFF1ZXVlKiBjcmVhdGVRdWV1ZSgpIHsKICAgIHN0cnVjdCBRdWV1ZSogcSA9IG1hbGxvYyhzaXplb2Yoc3RydWN0IFF1ZXVlKSk7CiAgICBxLT5mcm9udCA9IC0xOwogICAgcS0+cmVhciA9IC0xOwogICAgcmV0dXJuIHE7Cn0KCmludCBpc0VtcHR5KHN0cnVjdCBRdWV1ZSogcSkgewogICAgaWYgKHEtPnJlYXIgPT0gLTEpCiAgICAgICAgcmV0dXJuIDE7CiAgICBlbHNlCiAgICAgICAgcmV0dXJuIDA7Cn0KCnZvaWQgZW5xdWV1ZShzdHJ1Y3QgUXVldWUqIHEsIGludCB2YWx1ZSkgewogICAgaWYgKHEtPnJlYXIgPT0gOTkpCiAgICAgICAgcHJpbnRmKCJcblF1ZXVlIGlzIEZ1bGwhISIpOwogICAgZWxzZSB7CiAgICAgICAgaWYgKHEtPmZyb250ID09IC0xKQogICAgICAgICAgICBxLT5mcm9udCA9IDA7CiAgICAgICAgcS0+cmVhcisrOwogICAgICAgIHEtPml0ZW1zW3EtPnJlYXJdID0gdmFsdWU7CiAgICB9Cn0KCmludCBkZXF1ZXVlKHN0cnVjdCBRdWV1ZSogcSkgewogICAgaW50IGl0ZW07CiAgICBpZiAoaXNFbXB0eShxKSkgewogICAgICAgIHByaW50ZigiUXVldWUgaXMgZW1wdHkiKTsKICAgICAgICBpdGVtID0gLTE7CiAgICB9IGVsc2UgewogICAgICAgIGl0ZW0gPSBxLT5pdGVtc1txLT5mcm9udF07CiAgICAgICAgcS0+ZnJvbnQrKzsKICAgICAgICBpZiAocS0+ZnJvbnQgPiBxLT5yZWFyKSB7CiAgICAgICAgICAgIHEtPmZyb250ID0gcS0+cmVhciA9IC0xOwogICAgICAgIH0KICAgIH0KICAgIHJldHVybiBpdGVtOwp9Cgp2b2lkIEJGUyhzdHJ1Y3QgR3JhcGgqIGdyYXBoLCBpbnQgc3RhcnRWZXJ0ZXgpIHsKICAgIHN0cnVjdCBRdWV1ZSogcSA9IGNyZWF0ZVF1ZXVlKCk7CgogICAgZ3JhcGgtPnZpc2l0ZWRbc3RhcnRWZXJ0ZXhdID0gMTsKICAgIGVucXVldWUocSwgc3RhcnRWZXJ0ZXgpOwoKICAgIHdoaWxlICghaXNFbXB0eShxKSkgewogICAgICAgIGludCBjdXJyZW50VmVydGV4ID0gZGVxdWV1ZShxKTsKICAgICAgICBwcmludGYoIlZpc2l0ZWQgJWRcbiIsIGN1cnJlbnRWZXJ0ZXgpOwoKICAgICAgICBzdHJ1Y3QgTm9kZSogdGVtcCA9IGdyYXBoLT5hZGpMaXN0c1tjdXJyZW50VmVydGV4XTsKCiAgICAgICAgd2hpbGUgKHRlbXApIHsKICAgICAgICAgICAgaW50IGFkalZlcnRleCA9IHRlbXAtPnZlcnRleDsKCiAgICAgICAgICAgIGlmIChncmFwaC0+dmlzaXRlZFthZGpWZXJ0ZXhdID09IDApIHsKICAgICAgICAgICAgICAgIGdyYXBoLT52aXNpdGVkW2FkalZlcnRleF0gPSAxOwogICAgICAgICAgICAgICAgZW5xdWV1ZShxLCBhZGpWZXJ0ZXgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRlbXAgPSB0ZW1wLT5uZXh0OwogICAgICAgIH0KICAgIH0KfQoKaW50IG1haW4oKSB7CiAgICBzdHJ1Y3QgR3JhcGgqIGdyYXBoID0gY3JlYXRlR3JhcGgoNCk7CiAgICBhZGRFZGdlKGdyYXBoLCAwLCAxKTsKICAgIGFkZEVkZ2UoZ3JhcGgsIDAsIDIpOwogICAgYWRkRWRnZShncmFwaCwgMSwgMik7CiAgICBhZGRFZGdlKGdyYXBoLCAyLCAzKTsKCiAgICBCRlMoZ3JhcGgsIDApOwoKICAgIHJldHVybiAwOwp9"))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int vertex;
    struct Node* next;
};

struct Graph {
    int numVertices;
    struct Node** adjLists;
    int* visited;
};

struct Queue {
    int items[100];
    int front;
    int rear;
};

struct Node* createNode(int v) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode-&gt;vertex = v;
    newNode-&gt;next = NULL;
    return newNode;
}

struct Graph* createGraph(int vertices) {
    struct Graph* graph = malloc(sizeof(struct Graph));
    graph-&gt;numVertices = vertices;
    graph-&gt;adjLists = malloc(vertices * sizeof(struct Node*));
    graph-&gt;visited = malloc(vertices * sizeof(int));

    for (int i = 0; i &lt; vertices; i++) {
        graph-&gt;adjLists[i] = NULL;
        graph-&gt;visited[i] = 0;
    }

    return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
    struct Node* newNode = createNode(dest);
    newNode-&gt;next = graph-&gt;adjLists[src];
    graph-&gt;adjLists[src] = newNode;

    newNode = createNode(src);
    newNode-&gt;next = graph-&gt;adjLists[dest];
    graph-&gt;adjLists[dest] = newNode;
}

struct Queue* createQueue() {
    struct Queue* q = malloc(sizeof(struct Queue));
    q-&gt;front = -1;
    q-&gt;rear = -1;
    return q;
}

int isEmpty(struct Queue* q) {
    if (q-&gt;rear == -1)
        return 1;
    else
        return 0;
}

void enqueue(struct Queue* q, int value) {
    if (q-&gt;rear == 99)
        printf(&quot;\nQueue is Full!!&quot;);
    else {
        if (q-&gt;front == -1)
            q-&gt;front = 0;
        q-&gt;rear++;
        q-&gt;items[q-&gt;rear] = value;
    }
}

int dequeue(struct Queue* q) {
    int item;
    if (isEmpty(q)) {
        printf(&quot;Queue is empty&quot;);
        item = -1;
    } else {
        item = q-&gt;items[q-&gt;front];
        q-&gt;front++;
        if (q-&gt;front &gt; q-&gt;rear) {
            q-&gt;front = q-&gt;rear = -1;
        }
    }
    return item;
}

void BFS(struct Graph* graph, int startVertex) {
    struct Queue* q = createQueue();

    graph-&gt;visited[startVertex] = 1;
    enqueue(q, startVertex);

    while (!isEmpty(q)) {
        int currentVertex = dequeue(q);
        printf(&quot;Visited %d\n&quot;, currentVertex);

        struct Node* temp = graph-&gt;adjLists[currentVertex];

        while (temp) {
            int adjVertex = temp-&gt;vertex;

            if (graph-&gt;visited[adjVertex] == 0) {
                graph-&gt;visited[adjVertex] = 1;
                enqueue(q, adjVertex);
            }
            temp = temp-&gt;next;
        }
    }
}

int main() {
    struct Graph* graph = createGraph(4);
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 2);
    addEdge(graph, 2, 3);

    BFS(graph, 0);

    return 0;
}</pre></div><div class='content'></div><h1>Advanced Graph Algorithms</h1>
<div class='content'><p>Once you are comfortable with basic graph representations and traversals, you can explore more advanced algorithms.</p>
</div><h2>Dijkstra's Algorithm</h2>
<div class='content'><p>Dijkstra's algorithm finds the shortest path from a source vertex to all other vertices in a weighted graph.</p>
</div><h2>Floyd-Warshall Algorithm</h2>
<div class='content'><p>The Floyd-Warshall algorithm finds shortest paths between all pairs of vertices in a weighted graph.</p>
</div><h2>Topological Sorting</h2>
<div class='content'><p>Topological sorting is used for ordering vertices in a directed acyclic graph (DAG).</p>
</div><h1>Conclusion</h1>
<div class='content'><p>Graphs are a versatile and powerful data structure that can be used to solve a wide range of problems. By understanding how to represent, traverse, and apply algorithms to graphs, you can tackle complex problems in computer science and beyond. Practice implementing these concepts in C to solidify your understanding and improve your programming skills.</p>
</div><div class='row navigation'>
	<div class='col-4'>
					<a href='trees'>&#x25C4;Trees</a>
			</div>
	<div class='col-4 text-center'>
		<a href="./" class="title">Graphs in C</a>
	</div>
	<div class='col-4 text-end'>
					<a href='debugging-techniques'>Debugging Techniques &#x25BA;</a>
			</div>
</div>

			</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Advertising</h1>
			<p>This space is reserved for advertising.</p>
			<p>If you want to be a sponsor, contact us to include links in this area: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>Thank you for collaborating!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. All rights reserved</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Accept</a>
    <a href="/cookies">More Information</a>
</div>	

	</div>    
</body>
</html>
