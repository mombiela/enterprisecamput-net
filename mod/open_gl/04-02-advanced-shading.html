<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="index, follow, noarchive">
    <title>Advanced Shading Techniques</title>

    <link rel="alternate" href="https://campusempresa.com/mod/open_gl/04-02-advanced-shading" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/open_gl/04-02-advanced-shading" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/open_gl/04-02-advanced-shading" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css?v=4" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="/js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script>var DEVELOP = window.location.href.indexOf("localhost")!=-1 && true;</script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
	<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0611338592562725" crossorigin="anonymous"></script>  	
	</head>

<body >
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-12 col-md-6 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo-header_enterprise.png"></a>
			</h1>
		</div>
		<div class="col-12 col-md-6 p-0 text-end">
			<p class="mb-0 p-0">	<b id="lit_lang_es" class="px-2">EN</b>
	|
	<a href="https://campusempresa.com/mod/open_gl/04-02-advanced-shading" class="px-2">ES</a></b>
	|
	<a href="https://campusempresa.cat/mod/open_gl/04-02-advanced-shading" class="px-2">CA</a>
</p>
			<p class="mb-4 mt-0 mx-2  d-none d-md-block"><cite>All the knowledge within your reach</cite></p>
		</div>
	</div>
</div>
<div class="subheader container-xxl d-none d-md-block">
	<div class="row">
		<div class="col-12 p-2 p-md-0 m-0 text-end">
			<a href="/objective">The Project</a> | 
<a href="/about">About Us</a> | 
<a href="/contribute">Contribute</a> | 
<a href="/donate">Donations</a> | 
<a href="/licence">License</a>
		</div>
	</div>
</div>
		<div class="top-bar container-fluid p-0">
	<div class="container-xxl p-0">
		<div class="row">
			<div class="col" id="left_menu">
					<a href="/"  class="nav-link px-3">
		<i class="bi bi-house-fill"></i>
		HOME
	</a>

	<a href="./"  class="nav-link px-3">
		<i class="bi bi-journal-bookmark"></i>
		Course Content
	</a>

			</div>
		</div>
	</div>
</div>

<!--  
<div class="top-bar container-fluid">
	<div class="container-xxl">
		<nav class="navbar navbar-expand-md p-0">
			<div class="container-fluid">
				<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
				</button>
				
				<div class="collapse navbar-collapse" id="navbarNav">
					<div class="navbar-nav me-auto">
							<a href="/"  class="nav-link px-3">
		<i class="bi bi-house-fill"></i>
		HOME
	</a>

	<a href="./"  class="nav-link px-3">
		<i class="bi bi-journal-bookmark"></i>
		Course Content
	</a>

					</div>
				</div>			
							</div>
		</nav>
	</div>
</div>
 -->				<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content">
				<div class='row navigation'>
	<div class='col-1 col-md-2'>
					<a href='04-01-framebuffers-renderbuffers' title="Framebuffers and Renderbuffers">
				<span class="d-none d-md-inline">&#x25C4; Previous</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-left-square-fill"></i></span>
			</a>
			</div>
	<div class='col-10 col-md-8 text-center'>
					<h2 style="text-decoration:underline">Advanced Shading Techniques</h2>
			</div>
	<div class='col-1 col-md-2 text-end'>
					<a href='04-03-instanced-rendering' title="Instanced Rendering">
				<span class="d-none d-md-inline">Next &#x25BA;</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-right-square-fill"></i></span>
			</a>
			</div>
</div>
<div class='content'><p>In this section, we will delve into advanced shading techniques in OpenGL. Shading is a crucial aspect of rendering that determines how surfaces interact with light. Advanced shading techniques can significantly enhance the visual quality of your graphics.</p>
</div><h1>Key Concepts</h1>
<div class='content'><ol>
<li><strong>Phong Shading</strong></li>
<li><strong>Blinn-Phong Shading</strong></li>
<li><strong>Normal Mapping</strong></li>
<li><strong>Parallax Mapping</strong></li>
<li><strong>Physically Based Rendering (PBR)</strong></li>
</ol>
</div><h1><ol>
<li>Phong Shading</li>
</ol></h1>
<div class='content'><p>Phong Shading is a technique that interpolates surface normals across rasterized polygons and computes pixel colors based on the interpolated normals and a lighting model.</p>
</div><h2>Phong Shading Steps</h2>
<div class='content'><ol>
<li><strong>Vertex Shader</strong>: Calculate the vertex normals.</li>
<li><strong>Fragment Shader</strong>: Interpolate the normals and compute the lighting per pixel.</li>
</ol>
</div><h2>Example Code</h2>
<div class='content'><p><strong>Vertex Shader (Phong Shading)</strong></p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I3ZlcnNpb24gMzMwIGNvcmUKbGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMyBhUG9zOwpsYXlvdXQobG9jYXRpb24gPSAxKSBpbiB2ZWMzIGFOb3JtYWw7CgpvdXQgdmVjMyBGcmFnUG9zOwpvdXQgdmVjMyBOb3JtYWw7Cgp1bmlmb3JtIG1hdDQgbW9kZWw7CnVuaWZvcm0gbWF0NCB2aWV3Owp1bmlmb3JtIG1hdDQgcHJvamVjdGlvbjsKCnZvaWQgbWFpbigpCnsKICAgIEZyYWdQb3MgPSB2ZWMzKG1vZGVsICogdmVjNChhUG9zLCAxLjApKTsKICAgIE5vcm1hbCA9IG1hdDModHJhbnNwb3NlKGludmVyc2UobW9kZWwpKSkgKiBhTm9ybWFsOyAgCiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb24gKiB2aWV3ICogdmVjNChGcmFnUG9zLCAxLjApOwp9"))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#version 330 core
layout(location = 0) in vec3 aPos;
layout(location = 1) in vec3 aNormal;

out vec3 FragPos;
out vec3 Normal;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

void main()
{
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;  
    gl_Position = projection * view * vec4(FragPos, 1.0);
}</pre></div><div class='content'><p><strong>Fragment Shader (Phong Shading)</strong></p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I3ZlcnNpb24gMzMwIGNvcmUKb3V0IHZlYzQgRnJhZ0NvbG9yOwoKaW4gdmVjMyBGcmFnUG9zOwppbiB2ZWMzIE5vcm1hbDsKCnVuaWZvcm0gdmVjMyBsaWdodFBvczsKdW5pZm9ybSB2ZWMzIHZpZXdQb3M7CnVuaWZvcm0gdmVjMyBsaWdodENvbG9yOwp1bmlmb3JtIHZlYzMgb2JqZWN0Q29sb3I7Cgp2b2lkIG1haW4oKQp7CiAgICAvLyBBbWJpZW50CiAgICBmbG9hdCBhbWJpZW50U3RyZW5ndGggPSAwLjE7CiAgICB2ZWMzIGFtYmllbnQgPSBhbWJpZW50U3RyZW5ndGggKiBsaWdodENvbG9yOwogICAgCiAgICAvLyBEaWZmdXNlIAogICAgdmVjMyBub3JtID0gbm9ybWFsaXplKE5vcm1hbCk7CiAgICB2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKGxpZ2h0UG9zIC0gRnJhZ1Bvcyk7CiAgICBmbG9hdCBkaWZmID0gbWF4KGRvdChub3JtLCBsaWdodERpciksIDAuMCk7CiAgICB2ZWMzIGRpZmZ1c2UgPSBkaWZmICogbGlnaHRDb2xvcjsKICAgIAogICAgLy8gU3BlY3VsYXIKICAgIGZsb2F0IHNwZWN1bGFyU3RyZW5ndGggPSAwLjU7CiAgICB2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUodmlld1BvcyAtIEZyYWdQb3MpOwogICAgdmVjMyByZWZsZWN0RGlyID0gcmVmbGVjdCgtbGlnaHREaXIsIG5vcm0pOyAgCiAgICBmbG9hdCBzcGVjID0gcG93KG1heChkb3Qodmlld0RpciwgcmVmbGVjdERpciksIDAuMCksIDMyKTsKICAgIHZlYzMgc3BlY3VsYXIgPSBzcGVjdWxhclN0cmVuZ3RoICogc3BlYyAqIGxpZ2h0Q29sb3I7ICAKICAgIAogICAgdmVjMyByZXN1bHQgPSAoYW1iaWVudCArIGRpZmZ1c2UgKyBzcGVjdWxhcikgKiBvYmplY3RDb2xvcjsKICAgIEZyYWdDb2xvciA9IHZlYzQocmVzdWx0LCAxLjApOwp9"))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

void main()
{
    // Ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
    
    // Diffuse 
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Specular
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);  
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;  
    
    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = vec4(result, 1.0);
}</pre></div><div class='content'></div><h2>Explanation</h2>
<div class='content'><ul>
<li><strong>Ambient</strong>: A constant light that affects all objects equally.</li>
<li><strong>Diffuse</strong>: Light that is scattered in many directions when it hits a rough surface.</li>
<li><strong>Specular</strong>: The bright spot of light that appears on shiny objects.</li>
</ul>
</div><h1><ol start="2">
<li>Blinn-Phong Shading</li>
</ol></h1>
<div class='content'><p>Blinn-Phong Shading is a modification of Phong Shading that uses the halfway vector between the light direction and the view direction to calculate the specular reflection.</p>
</div><h2>Example Code</h2>
<div class='content'><p><strong>Fragment Shader (Blinn-Phong Shading)</strong></p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I3ZlcnNpb24gMzMwIGNvcmUKb3V0IHZlYzQgRnJhZ0NvbG9yOwoKaW4gdmVjMyBGcmFnUG9zOwppbiB2ZWMzIE5vcm1hbDsKCnVuaWZvcm0gdmVjMyBsaWdodFBvczsKdW5pZm9ybSB2ZWMzIHZpZXdQb3M7CnVuaWZvcm0gdmVjMyBsaWdodENvbG9yOwp1bmlmb3JtIHZlYzMgb2JqZWN0Q29sb3I7Cgp2b2lkIG1haW4oKQp7CiAgICAvLyBBbWJpZW50CiAgICBmbG9hdCBhbWJpZW50U3RyZW5ndGggPSAwLjE7CiAgICB2ZWMzIGFtYmllbnQgPSBhbWJpZW50U3RyZW5ndGggKiBsaWdodENvbG9yOwogICAgCiAgICAvLyBEaWZmdXNlIAogICAgdmVjMyBub3JtID0gbm9ybWFsaXplKE5vcm1hbCk7CiAgICB2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKGxpZ2h0UG9zIC0gRnJhZ1Bvcyk7CiAgICBmbG9hdCBkaWZmID0gbWF4KGRvdChub3JtLCBsaWdodERpciksIDAuMCk7CiAgICB2ZWMzIGRpZmZ1c2UgPSBkaWZmICogbGlnaHRDb2xvcjsKICAgIAogICAgLy8gU3BlY3VsYXIKICAgIGZsb2F0IHNwZWN1bGFyU3RyZW5ndGggPSAwLjU7CiAgICB2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUodmlld1BvcyAtIEZyYWdQb3MpOwogICAgdmVjMyBoYWxmd2F5RGlyID0gbm9ybWFsaXplKGxpZ2h0RGlyICsgdmlld0Rpcik7ICAKICAgIGZsb2F0IHNwZWMgPSBwb3cobWF4KGRvdChub3JtLCBoYWxmd2F5RGlyKSwgMC4wKSwgMzIpOwogICAgdmVjMyBzcGVjdWxhciA9IHNwZWN1bGFyU3RyZW5ndGggKiBzcGVjICogbGlnaHRDb2xvcjsgIAogICAgCiAgICB2ZWMzIHJlc3VsdCA9IChhbWJpZW50ICsgZGlmZnVzZSArIHNwZWN1bGFyKSAqIG9iamVjdENvbG9yOwogICAgRnJhZ0NvbG9yID0gdmVjNChyZXN1bHQsIDEuMCk7Cn0="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;
uniform vec3 objectColor;

void main()
{
    // Ambient
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;
    
    // Diffuse 
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;
    
    // Specular
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 halfwayDir = normalize(lightDir + viewDir);  
    float spec = pow(max(dot(norm, halfwayDir), 0.0), 32);
    vec3 specular = specularStrength * spec * lightColor;  
    
    vec3 result = (ambient + diffuse + specular) * objectColor;
    FragColor = vec4(result, 1.0);
}</pre></div><div class='content'></div><h2>Explanation</h2>
<div class='content'><ul>
<li><strong>Halfway Vector</strong>: A vector that is halfway between the light direction and the view direction, used to calculate the specular reflection more efficiently.</li>
</ul>
</div><h1><ol start="3">
<li>Normal Mapping</li>
</ol></h1>
<div class='content'><p>Normal Mapping is a technique used to add detail to the surface of a 3D model without increasing the number of polygons. It uses a texture (normal map) to perturb the normals of the surface.</p>
</div><h2>Example Code</h2>
<div class='content'><p><strong>Fragment Shader (Normal Mapping)</strong></p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I3ZlcnNpb24gMzMwIGNvcmUKb3V0IHZlYzQgRnJhZ0NvbG9yOwoKaW4gdmVjMyBGcmFnUG9zOwppbiB2ZWMyIFRleENvb3JkczsKaW4gdmVjMyBUYW5nZW50TGlnaHRQb3M7CmluIHZlYzMgVGFuZ2VudFZpZXdQb3M7CmluIHZlYzMgVGFuZ2VudEZyYWdQb3M7Cgp1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7CnVuaWZvcm0gc2FtcGxlcjJEIGRpZmZ1c2VNYXA7Cgp2b2lkIG1haW4oKQp7CiAgICAvLyBPYnRhaW4gbm9ybWFsIGZyb20gbm9ybWFsIG1hcCBpbiByYW5nZSBbMCwxXQogICAgdmVjMyBub3JtYWwgPSB0ZXh0dXJlKG5vcm1hbE1hcCwgVGV4Q29vcmRzKS5yZ2I7CiAgICAvLyBUcmFuc2Zvcm0gbm9ybWFsIHZlY3RvciB0byByYW5nZSBbLTEsMV0KICAgIG5vcm1hbCA9IG5vcm1hbGl6ZShub3JtYWwgKiAyLjAgLSAxLjApOyAgIAogICAgCiAgICAvLyBBbWJpZW50CiAgICB2ZWMzIGFtYmllbnQgPSAwLjEgKiB0ZXh0dXJlKGRpZmZ1c2VNYXAsIFRleENvb3JkcykucmdiOwogICAgCiAgICAvLyBEaWZmdXNlCiAgICB2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKFRhbmdlbnRMaWdodFBvcyAtIFRhbmdlbnRGcmFnUG9zKTsKICAgIGZsb2F0IGRpZmYgPSBtYXgoZG90KGxpZ2h0RGlyLCBub3JtYWwpLCAwLjApOwogICAgdmVjMyBkaWZmdXNlID0gZGlmZiAqIHRleHR1cmUoZGlmZnVzZU1hcCwgVGV4Q29vcmRzKS5yZ2I7CiAgICAKICAgIC8vIFNwZWN1bGFyCiAgICB2ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUoVGFuZ2VudFZpZXdQb3MgLSBUYW5nZW50RnJhZ1Bvcyk7CiAgICB2ZWMzIHJlZmxlY3REaXIgPSByZWZsZWN0KC1saWdodERpciwgbm9ybWFsKTsKICAgIGZsb2F0IHNwZWMgPSBwb3cobWF4KGRvdCh2aWV3RGlyLCByZWZsZWN0RGlyKSwgMC4wKSwgMzIuMCk7CiAgICB2ZWMzIHNwZWN1bGFyID0gdmVjMygwLjIpICogc3BlYzsKICAgIAogICAgdmVjMyByZXN1bHQgPSBhbWJpZW50ICsgZGlmZnVzZSArIHNwZWN1bGFyOwogICAgRnJhZ0NvbG9yID0gdmVjNChyZXN1bHQsIDEuMCk7Cn0="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec2 TexCoords;
in vec3 TangentLightPos;
in vec3 TangentViewPos;
in vec3 TangentFragPos;

uniform sampler2D normalMap;
uniform sampler2D diffuseMap;

void main()
{
    // Obtain normal from normal map in range [0,1]
    vec3 normal = texture(normalMap, TexCoords).rgb;
    // Transform normal vector to range [-1,1]
    normal = normalize(normal * 2.0 - 1.0);   
    
    // Ambient
    vec3 ambient = 0.1 * texture(diffuseMap, TexCoords).rgb;
    
    // Diffuse
    vec3 lightDir = normalize(TangentLightPos - TangentFragPos);
    float diff = max(dot(lightDir, normal), 0.0);
    vec3 diffuse = diff * texture(diffuseMap, TexCoords).rgb;
    
    // Specular
    vec3 viewDir = normalize(TangentViewPos - TangentFragPos);
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
    vec3 specular = vec3(0.2) * spec;
    
    vec3 result = ambient + diffuse + specular;
    FragColor = vec4(result, 1.0);
}</pre></div><div class='content'></div><h2>Explanation</h2>
<div class='content'><ul>
<li><strong>Normal Map</strong>: A texture that stores normal vectors in its RGB channels.</li>
<li><strong>Tangent Space</strong>: A coordinate system that is aligned with the surface of the model, used to correctly apply the normal map.</li>
</ul>
</div><h1><ol start="4">
<li>Parallax Mapping</li>
</ol></h1>
<div class='content'><p>Parallax Mapping is an enhancement of normal mapping that simulates depth by offsetting texture coordinates based on the view angle.</p>
</div><h2>Example Code</h2>
<div class='content'><p><strong>Fragment Shader (Parallax Mapping)</strong></p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I3ZlcnNpb24gMzMwIGNvcmUKb3V0IHZlYzQgRnJhZ0NvbG9yOwoKaW4gdmVjMyBGcmFnUG9zOwppbiB2ZWMyIFRleENvb3JkczsKaW4gdmVjMyBUYW5nZW50TGlnaHRQb3M7CmluIHZlYzMgVGFuZ2VudFZpZXdQb3M7CmluIHZlYzMgVGFuZ2VudEZyYWdQb3M7Cgp1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7CnVuaWZvcm0gc2FtcGxlcjJEIGRpZmZ1c2VNYXA7CnVuaWZvcm0gc2FtcGxlcjJEIGhlaWdodE1hcDsKCmZsb2F0IGhlaWdodFNjYWxlID0gMC4xOwoKdmVjMiBQYXJhbGxheE1hcHBpbmcodmVjMiB0ZXhDb29yZHMsIHZlYzMgdmlld0RpcikKewogICAgZmxvYXQgaGVpZ2h0ID0gdGV4dHVyZShoZWlnaHRNYXAsIHRleENvb3JkcykucjsgICAgIAogICAgdmVjMiBwID0gdmlld0Rpci54eSAqIChoZWlnaHQgKiBoZWlnaHRTY2FsZSk7IAogICAgcmV0dXJuIHRleENvb3JkcyAtIHA7ICAgCn0KCnZvaWQgbWFpbigpCnsKICAgIHZlYzMgdmlld0RpciA9IG5vcm1hbGl6ZShUYW5nZW50Vmlld1BvcyAtIFRhbmdlbnRGcmFnUG9zKTsKICAgIHZlYzIgdGV4Q29vcmRzID0gUGFyYWxsYXhNYXBwaW5nKFRleENvb3Jkcywgdmlld0Rpcik7CiAgICAKICAgIC8vIE9idGFpbiBub3JtYWwgZnJvbSBub3JtYWwgbWFwIGluIHJhbmdlIFswLDFdCiAgICB2ZWMzIG5vcm1hbCA9IHRleHR1cmUobm9ybWFsTWFwLCB0ZXhDb29yZHMpLnJnYjsKICAgIC8vIFRyYW5zZm9ybSBub3JtYWwgdmVjdG9yIHRvIHJhbmdlIFstMSwxXQogICAgbm9ybWFsID0gbm9ybWFsaXplKG5vcm1hbCAqIDIuMCAtIDEuMCk7ICAgCiAgICAKICAgIC8vIEFtYmllbnQKICAgIHZlYzMgYW1iaWVudCA9IDAuMSAqIHRleHR1cmUoZGlmZnVzZU1hcCwgdGV4Q29vcmRzKS5yZ2I7CiAgICAKICAgIC8vIERpZmZ1c2UKICAgIHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoVGFuZ2VudExpZ2h0UG9zIC0gVGFuZ2VudEZyYWdQb3MpOwogICAgZmxvYXQgZGlmZiA9IG1heChkb3QobGlnaHREaXIsIG5vcm1hbCksIDAuMCk7CiAgICB2ZWMzIGRpZmZ1c2UgPSBkaWZmICogdGV4dHVyZShkaWZmdXNlTWFwLCB0ZXhDb29yZHMpLnJnYjsKICAgIAogICAgLy8gU3BlY3VsYXIKICAgIHZlYzMgcmVmbGVjdERpciA9IHJlZmxlY3QoLWxpZ2h0RGlyLCBub3JtYWwpOwogICAgZmxvYXQgc3BlYyA9IHBvdyhtYXgoZG90KHZpZXdEaXIsIHJlZmxlY3REaXIpLCAwLjApLCAzMi4wKTsKICAgIHZlYzMgc3BlY3VsYXIgPSB2ZWMzKDAuMikgKiBzcGVjOwogICAgCiAgICB2ZWMzIHJlc3VsdCA9IGFtYmllbnQgKyBkaWZmdXNlICsgc3BlY3VsYXI7CiAgICBGcmFnQ29sb3IgPSB2ZWM0KHJlc3VsdCwgMS4wKTsKfQ=="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec2 TexCoords;
in vec3 TangentLightPos;
in vec3 TangentViewPos;
in vec3 TangentFragPos;

uniform sampler2D normalMap;
uniform sampler2D diffuseMap;
uniform sampler2D heightMap;

float heightScale = 0.1;

vec2 ParallaxMapping(vec2 texCoords, vec3 viewDir)
{
    float height = texture(heightMap, texCoords).r;     
    vec2 p = viewDir.xy * (height * heightScale); 
    return texCoords - p;   
}

void main()
{
    vec3 viewDir = normalize(TangentViewPos - TangentFragPos);
    vec2 texCoords = ParallaxMapping(TexCoords, viewDir);
    
    // Obtain normal from normal map in range [0,1]
    vec3 normal = texture(normalMap, texCoords).rgb;
    // Transform normal vector to range [-1,1]
    normal = normalize(normal * 2.0 - 1.0);   
    
    // Ambient
    vec3 ambient = 0.1 * texture(diffuseMap, texCoords).rgb;
    
    // Diffuse
    vec3 lightDir = normalize(TangentLightPos - TangentFragPos);
    float diff = max(dot(lightDir, normal), 0.0);
    vec3 diffuse = diff * texture(diffuseMap, texCoords).rgb;
    
    // Specular
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
    vec3 specular = vec3(0.2) * spec;
    
    vec3 result = ambient + diffuse + specular;
    FragColor = vec4(result, 1.0);
}</pre></div><div class='content'></div><h2>Explanation</h2>
<div class='content'><ul>
<li><strong>Height Map</strong>: A texture that stores height information in its channels.</li>
<li><strong>Parallax Mapping Function</strong>: Adjusts the texture coordinates based on the view direction and height map.</li>
</ul>
</div><h1><ol start="5">
<li>Physically Based Rendering (PBR)</li>
</ol></h1>
<div class='content'><p>PBR is a shading model that aims to simulate the physical properties of materials more accurately. It uses parameters like albedo, metallic, and roughness to achieve realistic lighting.</p>
</div><h2>Example Code</h2>
<div class='content'><p><strong>Fragment Shader (PBR)</strong></p>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("I3ZlcnNpb24gMzMwIGNvcmUKb3V0IHZlYzQgRnJhZ0NvbG9yOwoKaW4gdmVjMyBGcmFnUG9zOwppbiB2ZWMzIE5vcm1hbDsKaW4gdmVjMiBUZXhDb29yZHM7Cgp1bmlmb3JtIHZlYzMgbGlnaHRQb3M7CnVuaWZvcm0gdmVjMyB2aWV3UG9zOwp1bmlmb3JtIHZlYzMgbGlnaHRDb2xvcjsKCnVuaWZvcm0gc2FtcGxlcjJEIGFsYmVkb01hcDsKdW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxsaWNNYXA7CnVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc01hcDsKdW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7Cgpjb25zdCBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTk7Cgp2ZWMzIGdldE5vcm1hbEZyb21NYXAoKQp7CiAgICB2ZWMzIHRhbmdlbnROb3JtYWwgPSB0ZXh0dXJlKG5vcm1hbE1hcCwgVGV4Q29vcmRzKS54eXogKiAyLjAgLSAxLjA7CgogICAgdmVjMyBRMSAgPSBkRmR4KEZyYWdQb3MpOwogICAgdmVjMyBRMiAgPSBkRmR5KEZyYWdQb3MpOwogICAgdmVjMiBzdDEgPSBkRmR4KFRleENvb3Jkcyk7CiAgICB2ZWMyIHN0MiA9IGRGZHkoVGV4Q29vcmRzKTsKCiAgICB2ZWMzIE4gICA9IG5vcm1hbGl6ZShOb3JtYWwpOwogICAgdmVjMyBUICA9IG5vcm1hbGl6ZShRMSAqIHN0Mi50IC0gUTIgKiBzdDEudCk7CiAgICB2ZWMzIEIgID0gLW5vcm1hbGl6ZShjcm9zcyhOLCBUKSk7CiAgICBtYXQzIFRCTiA9IG1hdDMoVCwgQiwgTik7CgogICAgcmV0dXJuIG5vcm1hbGl6ZShUQk4gKiB0YW5nZW50Tm9ybWFsKTsKfQoKdm9pZCBtYWluKCkKewogICAgdmVjMyBhbGJlZG8gPSBwb3codGV4dHVyZShhbGJlZG9NYXAsIFRleENvb3JkcykucmdiLCB2ZWMzKDIuMikpOwogICAgZmxvYXQgbWV0YWxsaWMgPSB0ZXh0dXJlKG1ldGFsbGljTWFwLCBUZXhDb29yZHMpLnI7CiAgICBmbG9hdCByb3VnaG5lc3MgPSB0ZXh0dXJlKHJvdWdobmVzc01hcCwgVGV4Q29vcmRzKS5yOwogICAgZmxvYXQgYW8gPSB0ZXh0dXJlKGFvTWFwLCBUZXhDb29yZHMpLnI7CgogICAgdmVjMyBOID0gZ2V0Tm9ybWFsRnJvbU1hcCgpOwogICAgdmVjMyBWID0gbm9ybWFsaXplKHZpZXdQb3MgLSBGcmFnUG9zKTsKICAgIHZlYzMgTCA9IG5vcm1hbGl6ZShsaWdodFBvcyAtIEZyYWdQb3MpOwogICAgdmVjMyBIID0gbm9ybWFsaXplKFYgKyBMKTsKCiAgICBmbG9hdCBkaXN0YW5jZSA9IGxlbmd0aChsaWdodFBvcyAtIEZyYWdQb3MpOwogICAgZmxvYXQgYXR0ZW51YXRpb24gPSAxLjAgLyAoZGlzdGFuY2UgKiBkaXN0YW5jZSk7CiAgICB2ZWMzIHJhZGlhbmNlID0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uOwoKICAgIC8vIENvb2stVG9ycmFuY2UgQlJERgogICAgZmxvYXQgTkRGID0gRGlzdHJpYnV0aW9uR0dYKE4sIEgsIHJvdWdobmVzcyk7CiAgICBmbG9hdCBHICAgPSBHZW9tZXRyeVNtaXRoKE4sIFYsIEwsIHJvdWdobmVzcyk7CiAgICB2ZWMzIEYgICAgPSBmcmVzbmVsU2NobGljayhtYXgoZG90KEgsIFYpLCAwLjApLCBGMCk7CgogICAgdmVjMyBub21pbmF0b3IgICAgPSBOREYgKiBHICogRjsKICAgIGZsb2F0IGRlbm9taW5hdG9yID0gNC4wICogbWF4KGRvdChOLCBWKSwgMC4wKSAqIG1heChkb3QoTiwgTCksIDAuMCkgKyAwLjAwMTsKICAgIHZlYzMgc3BlY3VsYXIgPSBub21pbmF0b3IgLyBkZW5vbWluYXRvcjsKCiAgICB2ZWMzIGtTID0gRjsKICAgIHZlYzMga0QgPSB2ZWMzKDEuMCkgLSBrUzsKICAgIGtEICo9IDEuMCAtIG1ldGFsbGljOwoKICAgIGZsb2F0IE5kb3RMID0gbWF4KGRvdChOLCBMKSwgMC4wKTsKICAgIHZlYzMgTG8gPSAoa0QgKiBhbGJlZG8gLyBQSSArIHNwZWN1bGFyKSAqIHJhZGlhbmNlICogTmRvdEw7CgogICAgdmVjMyBhbWJpZW50ID0gdmVjMygwLjAzKSAqIGFsYmVkbyAqIGFvOwogICAgdmVjMyBjb2xvciA9IGFtYmllbnQgKyBMbzsKCiAgICBjb2xvciA9IGNvbG9yIC8gKGNvbG9yICsgdmVjMygxLjApKTsKICAgIGNvbG9yID0gcG93KGNvbG9yLCB2ZWMzKDEuMC8yLjIpKTsKCiAgICBGcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApOwp9"))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>#version 330 core
out vec4 FragColor;

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoords;

uniform vec3 lightPos;
uniform vec3 viewPos;
uniform vec3 lightColor;

uniform sampler2D albedoMap;
uniform sampler2D metallicMap;
uniform sampler2D roughnessMap;
uniform sampler2D aoMap;

const float PI = 3.14159265359;

vec3 getNormalFromMap()
{
    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;

    vec3 Q1  = dFdx(FragPos);
    vec3 Q2  = dFdy(FragPos);
    vec2 st1 = dFdx(TexCoords);
    vec2 st2 = dFdy(TexCoords);

    vec3 N   = normalize(Normal);
    vec3 T  = normalize(Q1 * st2.t - Q2 * st1.t);
    vec3 B  = -normalize(cross(N, T));
    mat3 TBN = mat3(T, B, N);

    return normalize(TBN * tangentNormal);
}

void main()
{
    vec3 albedo = pow(texture(albedoMap, TexCoords).rgb, vec3(2.2));
    float metallic = texture(metallicMap, TexCoords).r;
    float roughness = texture(roughnessMap, TexCoords).r;
    float ao = texture(aoMap, TexCoords).r;

    vec3 N = getNormalFromMap();
    vec3 V = normalize(viewPos - FragPos);
    vec3 L = normalize(lightPos - FragPos);
    vec3 H = normalize(V + L);

    float distance = length(lightPos - FragPos);
    float attenuation = 1.0 / (distance * distance);
    vec3 radiance = lightColor * attenuation;

    // Cook-Torrance BRDF
    float NDF = DistributionGGX(N, H, roughness);
    float G   = GeometrySmith(N, V, L, roughness);
    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);

    vec3 nominator    = NDF * G * F;
    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;
    vec3 specular = nominator / denominator;

    vec3 kS = F;
    vec3 kD = vec3(1.0) - kS;
    kD *= 1.0 - metallic;

    float NdotL = max(dot(N, L), 0.0);
    vec3 Lo = (kD * albedo / PI + specular) * radiance * NdotL;

    vec3 ambient = vec3(0.03) * albedo * ao;
    vec3 color = ambient + Lo;

    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2));

    FragColor = vec4(color, 1.0);
}</pre></div><div class='content'></div><h2>Explanation</h2>
<div class='content'><ul>
<li><strong>Albedo</strong>: The base color of the material.</li>
<li><strong>Metallic</strong>: Determines if the material is metallic.</li>
<li><strong>Roughness</strong>: Determines the roughness of the surface.</li>
<li><strong>Ambient Occlusion (AO)</strong>: Simulates the occlusion of ambient light.</li>
</ul>
</div><h1>Practical Exercises</h1>
<div class='content'></div><h2>Exercise 1: Implement Phong Shading</h2>
<div class='content'><ol>
<li>Create a simple 3D model (e.g., a cube).</li>
<li>Implement Phong Shading in the vertex and fragment shaders.</li>
<li>Adjust the light position and observe the changes in shading.</li>
</ol>
</div><h2>Solution</h2>
<div class='content'><p>Refer to the Phong Shading example code provided above.</p>
</div><h2>Exercise 2: Apply Normal Mapping</h2>
<div class='content'><ol>
<li>Create a 3D model with a normal map texture.</li>
<li>Implement normal mapping in the fragment shader.</li>
<li>Adjust the light position and observe the changes in surface detail.</li>
</ol>
</div><h2>Solution</h2>
<div class='content'><p>Refer to the Normal Mapping example code provided above.</p>
</div><h2>Exercise 3: Experiment with PBR</h2>
<div class='content'><ol>
<li>Create a 3D model with albedo, metallic, roughness, and AO textures.</li>
<li>Implement PBR in the fragment shader.</li>
<li>Adjust the light position and observe the realistic lighting effects.</li>
</ol>
</div><h2>Solution</h2>
<div class='content'><p>Refer to the PBR example code provided above.</p>
</div><h1>Common Mistakes and Tips</h1>
<div class='content'><ul>
<li><strong>Incorrect Normal Calculation</strong>: Ensure normals are correctly calculated and normalized.</li>
<li><strong>Texture Coordinates</strong>: Make sure texture coordinates are correctly mapped to the model.</li>
<li><strong>Lighting Calculations</strong>: Verify that lighting calculations are performed in the correct space (e.g., world space, view space).</li>
</ul>
</div><h1>Conclusion</h1>
<div class='content'><p>In this section, we explored advanced shading techniques in OpenGL, including Phong Shading, Blinn-Phong Shading, Normal Mapping, Parallax Mapping, and Physically Based Rendering (PBR). These techniques can significantly enhance the visual quality of your graphics by simulating realistic lighting and surface details. Practice implementing these techniques to gain a deeper understanding and improve your OpenGL rendering skills.</p>
</div><div class='row navigation'>
	<div class='col-1 col-md-2'>
					<a href='04-01-framebuffers-renderbuffers' title="Framebuffers and Renderbuffers">
				<span class="d-none d-md-inline">&#x25C4; Previous</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-left-square-fill"></i></span>
			</a>
			</div>
	<div class='col-10 col-md-8 text-center'>
			</div>
	<div class='col-1 col-md-2 text-end'>
					<a href='04-03-instanced-rendering' title="Instanced Rendering">
				<span class="d-none d-md-inline">Next &#x25BA;</span>
				<span class="d-inline d-md-none"><i class="bi bi-caret-right-square-fill"></i></span>
			</a>
			</div>
</div>

			</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
				<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-0611338592562725"
	     crossorigin="anonymous"></script>
	<!-- enterprise_campus -->
	<ins class="adsbygoogle"
	     style="display:block"
	     data-ad-client="ca-pub-0611338592562725"
	     data-ad-slot="6914733106"
	     data-ad-format="auto"
	     data-full-width-responsive="true"></ins>
	<script>
	     (adsbygoogle = window.adsbygoogle || []).push({});
	</script>
			
	<div class="container mt-2 d-none d-md-block index">
		<h1>OpenGL Programming Course</h1>
<h2>Module 1: Introduction to OpenGL</h2>
<ul>
<li><a href="01-01-what-is-opengl">What is OpenGL?</a></li>
<li><a href="01-02-setting-up-environment">Setting Up Your Development Environment</a></li>
<li><a href="01-03-first-opengl-program">Creating Your First OpenGL Program</a></li>
<li><a href="01-04-opengl-pipeline">Understanding the OpenGL Pipeline</a></li>
</ul>
<h2>Module 2: Basic Rendering</h2>
<ul>
<li><a href="02-01-drawing-basic-shapes">Drawing Basic Shapes</a></li>
<li><a href="02-02-coordinates-transformations">Understanding Coordinates and Transformations</a></li>
<li><a href="02-03-coloring-shading">Coloring and Shading</a></li>
<li><a href="02-04-using-buffers">Using Buffers</a></li>
</ul>
<h2>Module 3: Intermediate Rendering Techniques</h2>
<ul>
<li><a href="03-01-textures-mapping">Textures and Texture Mapping</a></li>
<li><a href="03-02-lighting-materials">Lighting and Materials</a></li>
<li><a href="03-03-blending-transparency">Blending and Transparency</a></li>
<li><a href="03-04-depth-stencil-testing">Depth Testing and Stencil Testing</a></li>
</ul>
<h2>Module 4: Advanced Rendering Techniques</h2>
<ul>
<li><a href="04-01-framebuffers-renderbuffers">Framebuffers and Renderbuffers</a></li>
<li><a href="04-02-advanced-shading">Advanced Shading Techniques</a></li>
<li><a href="04-03-instanced-rendering">Instanced Rendering</a></li>
<li><a href="04-04-tessellation">Tessellation</a></li>
</ul>
<h2>Module 5: Performance Optimization</h2>
<ul>
<li><a href="05-01-optimizing-code">Optimizing OpenGL Code</a></li>
<li><a href="05-02-using-vaos">Using Vertex Array Objects (VAOs)</a></li>
<li><a href="05-03-memory-management">Efficient Memory Management</a></li>
<li><a href="05-04-profiling-debugging">Profiling and Debugging</a></li>
</ul>
<h2>Module 6: Special Effects and Techniques</h2>
<ul>
<li><a href="06-01-particle-systems">Particle Systems</a></li>
<li><a href="06-02-post-processing">Post-Processing Effects</a></li>
<li><a href="06-03-shadow-mapping">Shadow Mapping</a></li>
<li><a href="06-04-environment-mapping">Environment Mapping</a></li>
</ul>
<h2>Module 7: Advanced Topics</h2>
<ul>
<li><a href="07-01-compute-shaders">Compute Shaders</a></li>
<li><a href="07-02-geometry-shaders">Geometry Shaders</a></li>
<li><a href="07-03-multi-pass-rendering">Multi-pass Rendering</a></li>
<li><a href="07-04-opengl-extensions">OpenGL Extensions</a></li>
</ul>
<h2>Module 8: Real-World Applications</h2>
<ul>
<li><a href="08-01-building-simple-game">Building a Simple Game</a></li>
<li><a href="08-02-3d-model-viewer">Creating a 3D Model Viewer</a></li>
<li><a href="08-03-developing-graphics-engine">Developing a Graphics Engine</a></li>
<li><a href="08-04-integrating-other-libraries">Integrating OpenGL with Other Libraries</a></li>
</ul>

	</div>










		</div>
	</div>
</div>		
<div class="container-xxl d-block d-md-none">
	<div class="row">
		<div class="col-12 p-2 p-md-0 m-0 text-end">
			<a href="/objective">The Project</a> | 
<a href="/about">About Us</a> | 
<a href="/contribute">Contribute</a> | 
<a href="/donate">Donations</a> | 
<a href="/licence">License</a>
		</div>
	</div>
</div>

<div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. All rights reserved</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	We use cookies to improve your user experience and offer content tailored to your interests.
    <a href="#" id="btn_accept_cookies" class="button">Accept</a>
    <a href="/cookies">More Information</a>
</div>	

	</div>    
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
</body>
</html>
