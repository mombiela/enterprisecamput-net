<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shortest Path Algorithms: Dijkstra and Floyd-Warshall</title>

    <link rel="alternate" href="https://campusempresa.com/mod/estructuras_datos/tema-32" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/mod/estructuras_datos/tema-32" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/mod/estructuras_datos/tema-32" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body  class="test" >
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo-header_enterprise.png"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Building today's and tomorrow's society</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
													<b id="lit_lang_es" class="px-2">EN</b>
				|
				<a href="https://campusempresa.com/mod/estructuras_datos/tema-32" class="px-2">ES</a></b>
				|
				<a href="https://campusempresa.cat/mod/estructuras_datos/tema-32" class="px-2">CA</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/objective">The Project</a>
				<a href="/about">About Us</a>
				<a href="/contribute">Contribute</a>
				<a href="/donate">Donations</a>
				<a href="/licence">License</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content">
									<div class="assert">
						<p><b>Attention!</b> There has been an error in the course generation, and it may contain translation errors.We are working to resolve this issue, so please use the content with caution.You can check the correct content in another language at the following link:<br>
						<a href="https://campusempresa.com/mod/estructuras_datos/tema-32">https://campusempresa.com/mod/estructuras_datos/tema-32</a></p>
					</div>
								<div class='content'></div><h1>Introduction</h1>
<div class='content'><p>In the field of data structures and algorithms, shortest path algorithms are fundamental for solving optimization problems in graphs. Two of the most well-known algorithms for this purpose are Dijkstra's algorithm and the Floyd-Warshall algorithm. This topic will cover both algorithms, explaining their fundamentals, applications, and providing code examples for practical understanding.</p>
</div><h1>Dijkstra's Algorithm</h1>
<div class='content'></div><h2>Description</h2>
<div class='content'><p>Dijkstra's algorithm is a shortest path search algorithm that finds the shortest path from a source node to all other nodes in a weighted graph with non-negative weights.</p>
</div><h2>Algorithm Steps</h2>
<div class='content'><ol>
<li>Initialize the distance to the source node as 0 and to all other nodes as infinity.</li>
<li>Mark all nodes as unvisited.</li>
<li>Select the unvisited node with the smallest distance.</li>
<li>Update the distance of the adjacent nodes to the selected node.</li>
<li>Mark the selected node as visited.</li>
<li>Repeat steps 3-5 until all nodes have been visited.</li>
</ol>
</div><h2>Code Example</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("aW1wb3J0IGhlYXBxCgpkZWYgZGlqa3N0cmEoZ3JhcGgsIHN0YXJ0KToKICAgICMgSW5pdGlhbGl6YXRpb24KICAgIGRpc3RhbmNlcyA9IHtub2RlOiBmbG9hdCgnaW5maW5pdHknKSBmb3Igbm9kZSBpbiBncmFwaH0KICAgIGRpc3RhbmNlc1tzdGFydF0gPSAwCiAgICBwcmlvcml0eV9xdWV1ZSA9IFsoMCwgc3RhcnQpXQogICAgCiAgICB3aGlsZSBwcmlvcml0eV9xdWV1ZToKICAgICAgICBjdXJyZW50X2Rpc3RhbmNlLCBjdXJyZW50X25vZGUgPSBoZWFwcS5oZWFwcG9wKHByaW9yaXR5X3F1ZXVlKQogICAgICAgIAogICAgICAgIGlmIGN1cnJlbnRfZGlzdGFuY2UgPiBkaXN0YW5jZXNbY3VycmVudF9ub2RlXToKICAgICAgICAgICAgY29udGludWUKICAgICAgICAKICAgICAgICBmb3IgbmVpZ2hib3IsIHdlaWdodCBpbiBncmFwaFtjdXJyZW50X25vZGVdLml0ZW1zKCk6CiAgICAgICAgICAgIGRpc3RhbmNlID0gY3VycmVudF9kaXN0YW5jZSArIHdlaWdodAogICAgICAgICAgICAKICAgICAgICAgICAgaWYgZGlzdGFuY2UgPCBkaXN0YW5jZXNbbmVpZ2hib3JdOgogICAgICAgICAgICAgICAgZGlzdGFuY2VzW25laWdoYm9yXSA9IGRpc3RhbmNlCiAgICAgICAgICAgICAgICBoZWFwcS5oZWFwcHVzaChwcmlvcml0eV9xdWV1ZSwgKGRpc3RhbmNlLCBuZWlnaGJvcikpCiAgICAKICAgIHJldHVybiBkaXN0YW5jZXMKCiMgVXNhZ2UgRXhhbXBsZQpncmFwaCA9IHsKICAgICdBJzogeydCJzogMSwgJ0MnOiA0fSwKICAgICdCJzogeydBJzogMSwgJ0MnOiAyLCAnRCc6IDV9LAogICAgJ0MnOiB7J0EnOiA0LCAnQic6IDIsICdEJzogMX0sCiAgICAnRCc6IHsnQic6IDUsICdDJzogMX0KfQoKcHJpbnQoZGlqa3N0cmEoZ3JhcGgsICdBJykp"))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>import heapq

def dijkstra(graph, start):
    # Initialization
    distances = {node: float('infinity') for node in graph}
    distances[start] = 0
    priority_queue = [(0, start)]
    
    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)
        
        if current_distance &gt; distances[current_node]:
            continue
        
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            
            if distance &lt; distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances

# Usage Example
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

print(dijkstra(graph, 'A'))</pre></div><div class='content'></div><h2>Applications</h2>
<div class='content'><ul>
<li>Telecommunications networks</li>
<li>GPS navigation systems</li>
<li>Route planning in logistics</li>
</ul>
</div><h1>Floyd-Warshall Algorithm</h1>
<div class='content'></div><h2>Description</h2>
<div class='content'><p>The Floyd-Warshall algorithm is a dynamic programming algorithm that finds the shortest paths between all pairs of nodes in a weighted graph, allowing negative weights but without negative cycles.</p>
</div><h2>Algorithm Steps</h2>
<div class='content'><ol>
<li>Create a distance matrix, where the entry (i, j) represents the distance from node i to node j.</li>
<li>Initialize the distance matrix with the weights of the graph's edges.</li>
<li>For each node k, update the distance matrix considering if passing through k reduces the distance between any pair of nodes (i, j).</li>
</ol>
</div><h2>Code Example</h2>
<div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGZsb3lkX3dhcnNoYWxsKGdyYXBoKToKICAgICMgSW5pdGlhbGl6YXRpb24KICAgIG5vZGVzID0gbGlzdChncmFwaC5rZXlzKCkpCiAgICBkaXN0ID0ge25vZGU6IHtub2RlOiBmbG9hdCgnaW5maW5pdHknKSBmb3Igbm9kZSBpbiBub2Rlc30gZm9yIG5vZGUgaW4gbm9kZXN9CiAgICAKICAgIGZvciBub2RlIGluIG5vZGVzOgogICAgICAgIGRpc3Rbbm9kZV1bbm9kZV0gPSAwCiAgICAgICAgZm9yIG5laWdoYm9yLCB3ZWlnaHQgaW4gZ3JhcGhbbm9kZV0uaXRlbXMoKToKICAgICAgICAgICAgZGlzdFtub2RlXVtuZWlnaGJvcl0gPSB3ZWlnaHQKICAgIAogICAgIyBEaXN0YW5jZSB1cGRhdGVzCiAgICBmb3IgayBpbiBub2RlczoKICAgICAgICBmb3IgaSBpbiBub2RlczoKICAgICAgICAgICAgZm9yIGogaW4gbm9kZXM6CiAgICAgICAgICAgICAgICBpZiBkaXN0W2ldW2pdID4gZGlzdFtpXVtrXSArIGRpc3Rba11bal06CiAgICAgICAgICAgICAgICAgICAgZGlzdFtpXVtqXSA9IGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdCiAgICAKICAgIHJldHVybiBkaXN0CgojIFVzYWdlIEV4YW1wbGUKZ3JhcGggPSB7CiAgICAnQSc6IHsnQic6IDEsICdDJzogNH0sCiAgICAnQic6IHsnQSc6IDEsICdDJzogMiwgJ0QnOiA1fSwKICAgICdDJzogeydBJzogNCwgJ0InOiAyLCAnRCc6IDF9LAogICAgJ0QnOiB7J0InOiA1LCAnQyc6IDF9Cn0KCmRpc3RhbmNlcyA9IGZsb3lkX3dhcnNoYWxsKGdyYXBoKQpmb3Igbm9kZSwgZGlzdCBpbiBkaXN0YW5jZXMuaXRlbXMoKToKICAgIHByaW50KGYiRGlzdGFuY2VzIGZyb20ge25vZGV9OiB7ZGlzdH0iKQ=="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def floyd_warshall(graph):
    # Initialization
    nodes = list(graph.keys())
    dist = {node: {node: float('infinity') for node in nodes} for node in nodes}
    
    for node in nodes:
        dist[node][node] = 0
        for neighbor, weight in graph[node].items():
            dist[node][neighbor] = weight
    
    # Distance updates
    for k in nodes:
        for i in nodes:
            for j in nodes:
                if dist[i][j] &gt; dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist

# Usage Example
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

distances = floyd_warshall(graph)
for node, dist in distances.items():
    print(f&quot;Distances from {node}: {dist}&quot;)</pre></div><div class='content'></div><h2>Applications</h2>
<div class='content'><ul>
<li>Social network analysis</li>
<li>Recommendation systems</li>
<li>Route optimization in transportation networks</li>
</ul>
</div><h1>Comparison of Dijkstra and Floyd-Warshall</h1>
<div class='content'><table>
<thead>
<tr>
<th>Feature</th>
<th>Dijkstra</th>
<th>Floyd-Warshall</th>
</tr>
</thead>
<tbody>
<tr>
<td>Graph Type</td>
<td>Weighted, no negative weights</td>
<td>Weighted, allows negative weights</td>
</tr>
<tr>
<td>Time Complexity</td>
<td>O(V^2) with adjacency matrix, O(E + V log V) with heap</td>
<td>O(V^3)</td>
</tr>
<tr>
<td>Main Use</td>
<td>Shortest path from one node</td>
<td>Shortest paths between all pairs of nodes</td>
</tr>
<tr>
<td>Implementation</td>
<td>Simpler</td>
<td>More complex</td>
</tr>
</tbody>
</table>
</div><h1>Conclusion</h1>
<div class='content'><p>Dijkstra's and Floyd-Warshall's algorithms are powerful tools for solving shortest path problems in graphs. Dijkstra's is ideal for finding the shortest path from a single node to all others, while Floyd-Warshall is more suitable for finding shortest paths between all pairs of nodes. Understanding these algorithms and their applications is essential for any IT professional working with data structures and algorithms.</p>
</div>
			</div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Advertising</h1>
			<p>This space is reserved for advertising.</p>
			<p>If you want to be a sponsor, contact us to include links in this area: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>Thank you for collaborating!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. All rights reserved</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Accept</a>
    <a href="/cookies">More Information</a>
</div>	

	</div>    
</body>
</html>
