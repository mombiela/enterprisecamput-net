<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms</title>

    <link rel="alternate" href="https://campusempresa.com/algoritmos/algoritmos-de-ordenamiento" hreflang="es" />
	<link rel="alternate" href="https://campusempresa.cat/algoritmos/algoritmos-de-ordenamiento" hreflang="ca" />
	<link rel="alternate" href="https://enterprisecampus.net/algoritmos/algoritmos-de-ordenamiento" hreflang="en" />
    
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css">
	<link href="/css/site.css" rel="stylesheet">
	
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  	<script type="text/javascript" src="js/math_init.js"></script>
  	<script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js"></script>
  	<script type="text/javascript" src="/js/cookie.js"></script>
  	<script type="text/javascript" src="/js/main.js"></script>
</head>

<body>
    <div id="content">
		<div id="header" class="container-xxl">
	<div class="row">
		<div class="col-8 p-0">
			<h1 class="m-0 p-0">
				<a href="/"><img src="/img/logo_header.png" style="visibility:hiddenxx;"></a>
			</h1>
		</div>
		<div class="col-4 p-0 text-end">
			<h2 id="main_title"><cite>Building today's and tomorrow's society</cite></h2>
			<h3 id="main_subtitle"></h3>
		</div>
	</div>
</div>
<div class="container-xxl" style="margin-top: -1em;">
	<div class="row">
		<div class="col-12 p-0 m-0 text-end">
													<b id="lit_lang_es" class="px-2">EN</b>
				|
				<a href="https://campusempresa.com/algoritmos/algoritmos-de-ordenamiento" class="px-2">ES</a></b>
				|
				<a href="https://campusempresa.cat/algoritmos/algoritmos-de-ordenamiento" class="px-2">CA</a>
					</div>
	</div>
</div>
   <div class="top-bar container-fluid">
	<div class="container-xxl">
		<div class="row">
			<div class="col" id="left_menu">
				<a href="/objective">The Project</a>
				<a href="/about">About Us</a>
				<a href="/contribute">Contribute</a>
				<a href="/donate">Donations</a>
				<a href="/licence">License</a>
			</div>
		</div>
	</div>
   </div>

<div class="container-xxl" id="main_content">
	<div class="row">
		<div class="col-12 col-lg-8">
			<div id="nav1" class="navigation"></div>
			<div id="inner_content"><div class='content'></div><h1>Introduction</h1>
<div class='content'><p>Sorting algorithms are fundamental in computer science and are used to organize data in a specific order, either ascending or descending. These algorithms are essential for improving the efficiency of other operations such as searches and data merges.</p>
</div><h1>Types of Sorting Algorithms</h1>
<div class='content'><p>There are several types of sorting algorithms, each with its own characteristics and use cases. Below are descriptions of some of the most common ones:</p>
</div><h2>Bubble Sort</h2>
<div class='content'><ul>
<li><strong>Description</strong>: It is one of the simplest algorithms. It compares adjacent pairs and swaps them if they are in the wrong order.</li>
<li><strong>Complexity</strong>: O(n^2) in the worst and average cases.</li>
<li><strong>Advantages</strong>: Easy to understand and implement.</li>
<li><strong>Disadvantages</strong>: Inefficient for large data sets.</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGJ1YmJsZV9zb3J0KGFycik6CiAgICBuID0gbGVuKGFycikKICAgIGZvciBpIGluIHJhbmdlKG4pOgogICAgICAgIGZvciBqIGluIHJhbmdlKDAsIG4taS0xKToKICAgICAgICAgICAgaWYgYXJyW2pdID4gYXJyW2orMV06CiAgICAgICAgICAgICAgICBhcnJbal0sIGFycltqKzFdID0gYXJyW2orMV0sIGFycltqXQogICAgcmV0dXJuIGFycgoKIyBVc2FnZSBleGFtcGxlCmFyciA9IFs2NCwgMzQsIDI1LCAxMiwgMjIsIDExLCA5MF0KcHJpbnQoYnViYmxlX3NvcnQoYXJyKSk="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] &gt; arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# Usage example
arr = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(arr))</pre></div><div class='content'></div><h2>Selection Sort</h2>
<div class='content'><ul>
<li><strong>Description</strong>: Finds the smallest element and places it in the first position, then repeats the process for the rest of the array.</li>
<li><strong>Complexity</strong>: O(n^2) in the worst and average cases.</li>
<li><strong>Advantages</strong>: Fewer swaps compared to bubble sort.</li>
<li><strong>Disadvantages</strong>: Still inefficient for large data sets.</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIHNlbGVjdGlvbl9zb3J0KGFycik6CiAgICBuID0gbGVuKGFycikKICAgIGZvciBpIGluIHJhbmdlKG4pOgogICAgICAgIG1pbl9pZHggPSBpCiAgICAgICAgZm9yIGogaW4gcmFuZ2UoaSsxLCBuKToKICAgICAgICAgICAgaWYgYXJyW2pdIDwgYXJyW21pbl9pZHhdOgogICAgICAgICAgICAgICAgbWluX2lkeCA9IGoKICAgICAgICBhcnJbaV0sIGFyclttaW5faWR4XSA9IGFyclttaW5faWR4XSwgYXJyW2ldCiAgICByZXR1cm4gYXJyCgojIFVzYWdlIGV4YW1wbGUKYXJyID0gWzY0LCAyNSwgMTIsIDIyLCAxMV0KcHJpbnQoc2VsZWN0aW9uX3NvcnQoYXJyKSk="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] &lt; arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# Usage example
arr = [64, 25, 12, 22, 11]
print(selection_sort(arr))</pre></div><div class='content'></div><h2>Insertion Sort</h2>
<div class='content'><ul>
<li><strong>Description</strong>: Builds the sorted array one by one, taking an element and placing it in its correct position.</li>
<li><strong>Complexity</strong>: O(n^2) in the worst and average cases.</li>
<li><strong>Advantages</strong>: Efficient for small or nearly sorted data sets.</li>
<li><strong>Disadvantages</strong>: Inefficient for large data sets.</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIGluc2VydGlvbl9zb3J0KGFycik6CiAgICBmb3IgaSBpbiByYW5nZSgxLCBsZW4oYXJyKSk6CiAgICAgICAga2V5ID0gYXJyW2ldCiAgICAgICAgaiA9IGktMQogICAgICAgIHdoaWxlIGogPj0gMCBhbmQga2V5IDwgYXJyW2pdOgogICAgICAgICAgICBhcnJbaiArIDFdID0gYXJyW2pdCiAgICAgICAgICAgIGogLT0gMQogICAgICAgIGFycltqICsgMV0gPSBrZXkKICAgIHJldHVybiBhcnIKCiMgVXNhZ2UgZXhhbXBsZQphcnIgPSBbMTIsIDExLCAxMywgNSwgNl0KcHJpbnQoaW5zZXJ0aW9uX3NvcnQoYXJyKSk="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j &gt;= 0 and key &lt; arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Usage example
arr = [12, 11, 13, 5, 6]
print(insertion_sort(arr))</pre></div><div class='content'></div><h2>Quick Sort</h2>
<div class='content'><ul>
<li><strong>Description</strong>: Uses the &quot;divide and conquer&quot; approach. Selects a 'pivot' and partitions the array into two sub-arrays, then sorts the sub-arrays recursively.</li>
<li><strong>Complexity</strong>: O(n log n) in the best and average cases, O(n^2) in the worst case.</li>
<li><strong>Advantages</strong>: Very efficient in practice for large data sets.</li>
<li><strong>Disadvantages</strong>: Can be inefficient in the worst case if the pivot is not chosen well.</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIHF1aWNrX3NvcnQoYXJyKToKICAgIGlmIGxlbihhcnIpIDw9IDE6CiAgICAgICAgcmV0dXJuIGFycgogICAgZWxzZToKICAgICAgICBwaXZvdCA9IGFycltsZW4oYXJyKSAvLyAyXQogICAgICAgIGxlZnQgPSBbeCBmb3IgeCBpbiBhcnIgaWYgeCA8IHBpdm90XQogICAgICAgIG1pZGRsZSA9IFt4IGZvciB4IGluIGFyciBpZiB4ID09IHBpdm90XQogICAgICAgIHJpZ2h0ID0gW3ggZm9yIHggaW4gYXJyIGlmIHggPiBwaXZvdF0KICAgICAgICByZXR1cm4gcXVpY2tfc29ydChsZWZ0KSArIG1pZGRsZSArIHF1aWNrX3NvcnQocmlnaHQpCgojIFVzYWdlIGV4YW1wbGUKYXJyID0gWzMsIDYsIDgsIDEwLCAxLCAyLCAxXQpwcmludChxdWlja19zb3J0KGFycikp"))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def quick_sort(arr):
    if len(arr) &lt;= 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x &lt; pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x &gt; pivot]
        return quick_sort(left) + middle + quick_sort(right)

# Usage example
arr = [3, 6, 8, 10, 1, 2, 1]
print(quick_sort(arr))</pre></div><div class='content'></div><h2>Merge Sort</h2>
<div class='content'><ul>
<li><strong>Description</strong>: Also uses the &quot;divide and conquer&quot; approach. Divides the array into two halves, sorts them recursively, and then merges them.</li>
<li><strong>Complexity</strong>: O(n log n) in all cases.</li>
<li><strong>Advantages</strong>: Very efficient and stable.</li>
<li><strong>Disadvantages</strong>: Requires additional space for merging.</li>
</ul>
</div><div style='position:relative'><a class='copy_button' href='#' onclick='navigator.clipboard.writeText(decodeURIComponent(escape(atob("ZGVmIG1lcmdlX3NvcnQoYXJyKToKICAgIGlmIGxlbihhcnIpID4gMToKICAgICAgICBtaWQgPSBsZW4oYXJyKSAvLyAyCiAgICAgICAgTCA9IGFycls6bWlkXQogICAgICAgIFIgPSBhcnJbbWlkOl0KCiAgICAgICAgbWVyZ2Vfc29ydChMKQogICAgICAgIG1lcmdlX3NvcnQoUikKCiAgICAgICAgaSA9IGogPSBrID0gMAoKICAgICAgICB3aGlsZSBpIDwgbGVuKEwpIGFuZCBqIDwgbGVuKFIpOgogICAgICAgICAgICBpZiBMW2ldIDwgUltqXToKICAgICAgICAgICAgICAgIGFycltrXSA9IExbaV0KICAgICAgICAgICAgICAgIGkgKz0gMQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgYXJyW2tdID0gUltqXQogICAgICAgICAgICAgICAgaiArPSAxCiAgICAgICAgICAgIGsgKz0gMQoKICAgICAgICB3aGlsZSBpIDwgbGVuKEwpOgogICAgICAgICAgICBhcnJba10gPSBMW2ldCiAgICAgICAgICAgIGkgKz0gMQogICAgICAgICAgICBrICs9IDEKCiAgICAgICAgd2hpbGUgaiA8IGxlbihSKToKICAgICAgICAgICAgYXJyW2tdID0gUltqXQogICAgICAgICAgICBqICs9IDEKICAgICAgICAgICAgayArPSAxCiAgICByZXR1cm4gYXJyCgojIFVzYWdlIGV4YW1wbGUKYXJyID0gWzEyLCAxMSwgMTMsIDUsIDYsIDddCnByaW50KG1lcmdlX3NvcnQoYXJyKSk="))));alert("Copied!");return false;'><i class='bi bi-copy'></i></a><pre class='code'>def merge_sort(arr):
    if len(arr) &gt; 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]

        merge_sort(L)
        merge_sort(R)

        i = j = k = 0

        while i &lt; len(L) and j &lt; len(R):
            if L[i] &lt; R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        while i &lt; len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j &lt; len(R):
            arr[k] = R[j]
            j += 1
            k += 1
    return arr

# Usage example
arr = [12, 11, 13, 5, 6, 7]
print(merge_sort(arr))</pre></div><div class='content'></div><h1>Comparison of Sorting Algorithms</h1>
<div class='content'><p>| Algorithm          | Complexity (Best) | Complexity (Average) | Complexity (Worst) | Additional Space | Stability |
|--------------------|-------------------|----------------------|--------------------|------------------|-----------|
| Bubble Sort        | O(n)              | O(n^2)               | O(n^2)             | O(1)             | Yes       |
| Selection Sort     | O(n^2)            | O(n^2)               | O(n^2)             | O(1)             | No        |
| Insertion Sort     | O(n)              | O(n^2)               | O(n^2)             | O(1)             | Yes       |
| Quick Sort         | O(n log n)        | O(n log n)           | O(n^2)             | O(log n)         | No        |
| Merge Sort         | O(n log n)        | O(n log n)           | O(n log n)         | O(n)             | Yes       |</p>
</div><h1>Conclusion</h1>
<div class='content'><p>Sorting algorithms are essential tools in programming and computer science. Each algorithm has its own advantages and disadvantages, and the choice of the appropriate algorithm depends on the context and characteristics of the data set to be sorted. It is important to understand the differences in complexity and efficiency to select the most suitable algorithm for each situation.</p>
</div></div>
		</div>
		<div class="col-12 col-lg-4 publi" id="div_publi">
			<h1>Advertising</h1>
			<p>This space is reserved for advertising.</p>
			<p>If you want to be a sponsor, contact us to include links in this area: <a href='mailto:admin@campusempresa.cat'>admin@campusempresa.cat</a></p>
			<p>Thank you for collaborating!</p>
		</div>
	</div>
</div>

   <div class="container-xxl my-3">
	<div class="row">
		<div class="col">
			<footer>&copy; Copyright 2024. All rights reserved</footer>
		</div>
	</div>
</div>	

<div id="cookies_adv" style="display:none;">
	Fem servir galetes per millorar la teva experiència d'ús i oferir continguts adaptats als teus interessos
    <a href="#" id="btn_accept_cookies" class="button">Accept</a>
    <a href="/cookies">More Information</a>
</div>	

	</div>    
</body>
</html>
